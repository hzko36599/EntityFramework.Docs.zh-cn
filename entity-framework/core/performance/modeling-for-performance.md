---
title: 性能建模-EF Core
description: 使用 Entity Framework Core 时有效建模
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657712"
---
# <a name="modeling-for-performance"></a>性能建模

在许多情况下，模型的方式可能对应用程序的性能产生深远的影响;尽管正确规范化和 "正确" 模型通常是一个很好的起点，但在实际应用程序中，一些标准化的折衷可以很好地实现良好的性能。 由于应用程序在生产环境中运行时，更改模型非常困难，因此在创建初始模型时，有必要保持性能。

## <a name="denormalization-and-caching"></a>非规范化和缓存

非 *规范化* 是将冗余数据添加到架构的做法，通常是为了在查询时消除联接。 例如，对于包含博客和帖子的模型，其中每篇文章都有相应的评分，你可能需要频繁地显示博客的平均评分。 这种方法的简单方法是按博客对文章进行分组，并将平均值作为查询的一部分进行计算;但这需要在两个表之间进行昂贵的联接。 非规范化方法会将所有发布的计算平均值添加到博客上的新列，使其可以立即访问，而无需进行联接或计算。

上述内容可以作为 *缓存* 的一种形式来查看，其中的日志聚合信息会缓存在其博客上;与任何缓存一样，问题在于如何使缓存的值与它缓存的数据保持最新。 在许多情况下，将缓存的数据延迟一小的时间;例如，在上面的示例中，通常可以合理地将博客的平均评级设置为在任何给定点都不是最新的。 如果是这种情况，你可以让它每开始重新计算一次，然后，否则，必须设置更复杂的系统，以使缓存的值保持最新。

下面详细介绍了 EF Core 中的非规范化和缓存的一些方法，并指向文档中的相关部分。

### <a name="stored-computed-columns"></a>存储计算列

如果要缓存的数据是同一个表中的其他列的积，则 [存储计算列](xref:core/modeling/generated-properties#computed-columns) 可以是理想的解决方案。 例如， `Customer` 可以包含 `FirstName` 和 `LastName` 列，但可能需要按客户的 *全名* 搜索。 数据库将自动维护存储的计算列（只要更改该行，就会对其进行重新计算），甚至可以为其定义索引以加快查询速度。

### <a name="update-cache-columns-when-inputs-change"></a>输入更改时更新缓存列

如果缓存列需要从表的行外部引用输入，则不能使用计算列。 但是，只要输入发生更改，就仍然可以重新计算列;例如，你可以在每次更改、添加或删除帖子时重新计算平均的博客评级。 请确保在需要重新计算时确定确切的条件，否则缓存值将不同步。

实现此目的的一种方法是，通过常规 EF Core API 自行执行更新。 `SaveChanges`可以使用 [事件](xref:core/logging-events-diagnostics/events) 或 [拦截](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) 程序自动检查是否有任何帖子正在更新，并执行此方法的重新计算。 请注意，这通常会产生额外的数据库往返，因为必须发送其他命令。

对于更高性能的应用程序，可以将数据库触发器定义为自动在数据库中执行重新计算。 这会节省额外的数据库往返次数，自动发生在与主更新相同的事务中，并且可以更简单地进行设置。 EF 并不提供任何特定的 API 来创建或维护触发器，但 [通过原始 SQL 创建空迁移并添加触发器定义](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)是完全不错的。

### <a name="materialized-views"></a>具体化视图

具体化视图与常规视图类似，不同之处在于它们的数据存储在磁盘上 ( "具体化" ) ，而不是每次查询视图时都进行计算。 如果您不希望只是向现有数据库添加单个缓存列，而是想要缓存复杂且开销较高的查询结果（就像它是常规表），则此工具非常有用。然后，可以在不进行任何计算或联接的情况下查询成本的结果。 与计算列不同，具体化视图在其基础表发生更改时不会自动更新-必须手动刷新。 如果缓存的数据可能滞后，则可以通过计时器来刷新视图;另一种方法是将数据库触发器设置为在某些数据库事件发生后查看具体化视图。

EF 当前不提供任何特定的 API 来创建或维护视图，具体化或以其他方式实现;但 [创建空迁移并通过原始 SQL 添加视图定义](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)是完全不错的。

## <a name="inheritance-mapping"></a>继承映射

建议在继续此部分之前，先阅读 [继承的专用页面](xref:core/modeling/inheritance) 。

EF Core 当前支持使用两种方法将继承模型映射到关系数据库：

* **每个层次结构一个表** (TPH) ，其中类的整个 .net 层次结构映射到单个数据库表
* **每种类型一个表** (TPT) ，其中 .net 层次结构中的每个类型都映射到数据库中的其他表。

继承映射技术的选择可能会对应用程序性能产生相当大的影响，因此建议在提交到选项之前仔细进行度量。

人们有时会选择 TPT，因为它看起来像是 "清洗" 技术;为每个 .NET 类型提供一个单独的表，使数据库架构看起来与 .NET 类型层次结构类似。 此外，因为 TPH 必须在单个表中表示整个层次结构，所以，不管行中实际保存的类型如何，行都具有 *所有* 列，并且不相关的列始终为空且未使用。 除了看似是 "unclean" 映射技术以外，很多人相信这些空列在数据库中占用的空间很大，并且可能会影响性能。

然而，测量表明，从性能角度来看，TPT 是最差的映射方法;其中，TPH 中的所有数据都来自单个表，TPT 查询必须将多个表联接在一起，而联接是关系数据库中性能问题的主要原因之一。 数据库通常还会很好地处理空列，而诸如 [SQL Server 稀疏列](/sql/relational-databases/tables/use-sparse-columns) 之类的功能可以更进一步地降低此开销。

有关具体示例， [请参阅此基准，此基准](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) 设置具有7类型层次结构的简单模型;5000行是每个累计35000行的种子，而基准只是从数据库加载所有行：

| 方法 |     平均值 |   错误 |  标准偏差 |     第0代 |     第1代 |     第2代 | 已分配 |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    TPH | 132.3 ms | 2.29 ms | 2.03 ms | 8000.0000 | 3000.0000 | 1250.0000 |  44.49 MB |
|    TPT | 201.3 ms | 3.32 ms | 3.10 ms | 9000.0000 | 4000.0000 |         - |  61.84 MB |

正如您所见，对于这种情况，TPH 比 TPT 的效率更高。 请注意，实际结果始终取决于所执行的特定查询和层次结构中的表数，因此其他查询可能会显示不同的性能差距;建议使用此基准代码作为模板来测试其他查询。
