---
title: 性能建模-EF Core
description: 使用 Entity Framework Core 时有效建模
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657712"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="900af-103">性能建模</span><span class="sxs-lookup"><span data-stu-id="900af-103">Modeling for Performance</span></span>

<span data-ttu-id="900af-104">在许多情况下，模型的方式可能对应用程序的性能产生深远的影响;尽管正确规范化和 "正确" 模型通常是一个很好的起点，但在实际应用程序中，一些标准化的折衷可以很好地实现良好的性能。</span><span class="sxs-lookup"><span data-stu-id="900af-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="900af-105">由于应用程序在生产环境中运行时，更改模型非常困难，因此在创建初始模型时，有必要保持性能。</span><span class="sxs-lookup"><span data-stu-id="900af-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="900af-106">非规范化和缓存</span><span class="sxs-lookup"><span data-stu-id="900af-106">Denormalization and caching</span></span>

<span data-ttu-id="900af-107">非 *规范化* 是将冗余数据添加到架构的做法，通常是为了在查询时消除联接。</span><span class="sxs-lookup"><span data-stu-id="900af-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="900af-108">例如，对于包含博客和帖子的模型，其中每篇文章都有相应的评分，你可能需要频繁地显示博客的平均评分。</span><span class="sxs-lookup"><span data-stu-id="900af-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="900af-109">这种方法的简单方法是按博客对文章进行分组，并将平均值作为查询的一部分进行计算;但这需要在两个表之间进行昂贵的联接。</span><span class="sxs-lookup"><span data-stu-id="900af-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="900af-110">非规范化方法会将所有发布的计算平均值添加到博客上的新列，使其可以立即访问，而无需进行联接或计算。</span><span class="sxs-lookup"><span data-stu-id="900af-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="900af-111">上述内容可以作为 *缓存* 的一种形式来查看，其中的日志聚合信息会缓存在其博客上;与任何缓存一样，问题在于如何使缓存的值与它缓存的数据保持最新。</span><span class="sxs-lookup"><span data-stu-id="900af-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="900af-112">在许多情况下，将缓存的数据延迟一小的时间;例如，在上面的示例中，通常可以合理地将博客的平均评级设置为在任何给定点都不是最新的。</span><span class="sxs-lookup"><span data-stu-id="900af-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="900af-113">如果是这种情况，你可以让它每开始重新计算一次，然后，否则，必须设置更复杂的系统，以使缓存的值保持最新。</span><span class="sxs-lookup"><span data-stu-id="900af-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="900af-114">下面详细介绍了 EF Core 中的非规范化和缓存的一些方法，并指向文档中的相关部分。</span><span class="sxs-lookup"><span data-stu-id="900af-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="900af-115">存储计算列</span><span class="sxs-lookup"><span data-stu-id="900af-115">Stored computed columns</span></span>

<span data-ttu-id="900af-116">如果要缓存的数据是同一个表中的其他列的积，则 [存储计算列](xref:core/modeling/generated-properties#computed-columns) 可以是理想的解决方案。</span><span class="sxs-lookup"><span data-stu-id="900af-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="900af-117">例如， `Customer` 可以包含 `FirstName` 和 `LastName` 列，但可能需要按客户的 *全名* 搜索。</span><span class="sxs-lookup"><span data-stu-id="900af-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="900af-118">数据库将自动维护存储的计算列（只要更改该行，就会对其进行重新计算），甚至可以为其定义索引以加快查询速度。</span><span class="sxs-lookup"><span data-stu-id="900af-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="900af-119">输入更改时更新缓存列</span><span class="sxs-lookup"><span data-stu-id="900af-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="900af-120">如果缓存列需要从表的行外部引用输入，则不能使用计算列。</span><span class="sxs-lookup"><span data-stu-id="900af-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="900af-121">但是，只要输入发生更改，就仍然可以重新计算列;例如，你可以在每次更改、添加或删除帖子时重新计算平均的博客评级。</span><span class="sxs-lookup"><span data-stu-id="900af-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="900af-122">请确保在需要重新计算时确定确切的条件，否则缓存值将不同步。</span><span class="sxs-lookup"><span data-stu-id="900af-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="900af-123">实现此目的的一种方法是，通过常规 EF Core API 自行执行更新。</span><span class="sxs-lookup"><span data-stu-id="900af-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="900af-124">`SaveChanges`可以使用 [事件](xref:core/logging-events-diagnostics/events) 或 [拦截](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) 程序自动检查是否有任何帖子正在更新，并执行此方法的重新计算。</span><span class="sxs-lookup"><span data-stu-id="900af-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="900af-125">请注意，这通常会产生额外的数据库往返，因为必须发送其他命令。</span><span class="sxs-lookup"><span data-stu-id="900af-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="900af-126">对于更高性能的应用程序，可以将数据库触发器定义为自动在数据库中执行重新计算。</span><span class="sxs-lookup"><span data-stu-id="900af-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="900af-127">这会节省额外的数据库往返次数，自动发生在与主更新相同的事务中，并且可以更简单地进行设置。</span><span class="sxs-lookup"><span data-stu-id="900af-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="900af-128">EF 并不提供任何特定的 API 来创建或维护触发器，但 [通过原始 SQL 创建空迁移并添加触发器定义](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)是完全不错的。</span><span class="sxs-lookup"><span data-stu-id="900af-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="900af-129">具体化视图</span><span class="sxs-lookup"><span data-stu-id="900af-129">Materialized views</span></span>

<span data-ttu-id="900af-130">具体化视图与常规视图类似，不同之处在于它们的数据存储在磁盘上 ( "具体化" ) ，而不是每次查询视图时都进行计算。</span><span class="sxs-lookup"><span data-stu-id="900af-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="900af-131">如果您不希望只是向现有数据库添加单个缓存列，而是想要缓存复杂且开销较高的查询结果（就像它是常规表），则此工具非常有用。然后，可以在不进行任何计算或联接的情况下查询成本的结果。</span><span class="sxs-lookup"><span data-stu-id="900af-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="900af-132">与计算列不同，具体化视图在其基础表发生更改时不会自动更新-必须手动刷新。</span><span class="sxs-lookup"><span data-stu-id="900af-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="900af-133">如果缓存的数据可能滞后，则可以通过计时器来刷新视图;另一种方法是将数据库触发器设置为在某些数据库事件发生后查看具体化视图。</span><span class="sxs-lookup"><span data-stu-id="900af-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="900af-134">EF 当前不提供任何特定的 API 来创建或维护视图，具体化或以其他方式实现;但 [创建空迁移并通过原始 SQL 添加视图定义](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)是完全不错的。</span><span class="sxs-lookup"><span data-stu-id="900af-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="900af-135">继承映射</span><span class="sxs-lookup"><span data-stu-id="900af-135">Inheritance mapping</span></span>

<span data-ttu-id="900af-136">建议在继续此部分之前，先阅读 [继承的专用页面](xref:core/modeling/inheritance) 。</span><span class="sxs-lookup"><span data-stu-id="900af-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="900af-137">EF Core 当前支持使用两种方法将继承模型映射到关系数据库：</span><span class="sxs-lookup"><span data-stu-id="900af-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="900af-138">**每个层次结构一个表** (TPH) ，其中类的整个 .net 层次结构映射到单个数据库表</span><span class="sxs-lookup"><span data-stu-id="900af-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="900af-139">**每种类型一个表** (TPT) ，其中 .net 层次结构中的每个类型都映射到数据库中的其他表。</span><span class="sxs-lookup"><span data-stu-id="900af-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="900af-140">继承映射技术的选择可能会对应用程序性能产生相当大的影响，因此建议在提交到选项之前仔细进行度量。</span><span class="sxs-lookup"><span data-stu-id="900af-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="900af-141">人们有时会选择 TPT，因为它看起来像是 "清洗" 技术;为每个 .NET 类型提供一个单独的表，使数据库架构看起来与 .NET 类型层次结构类似。</span><span class="sxs-lookup"><span data-stu-id="900af-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="900af-142">此外，因为 TPH 必须在单个表中表示整个层次结构，所以，不管行中实际保存的类型如何，行都具有 *所有* 列，并且不相关的列始终为空且未使用。</span><span class="sxs-lookup"><span data-stu-id="900af-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="900af-143">除了看似是 "unclean" 映射技术以外，很多人相信这些空列在数据库中占用的空间很大，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="900af-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="900af-144">然而，测量表明，从性能角度来看，TPT 是最差的映射方法;其中，TPH 中的所有数据都来自单个表，TPT 查询必须将多个表联接在一起，而联接是关系数据库中性能问题的主要原因之一。</span><span class="sxs-lookup"><span data-stu-id="900af-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="900af-145">数据库通常还会很好地处理空列，而诸如 [SQL Server 稀疏列](/sql/relational-databases/tables/use-sparse-columns) 之类的功能可以更进一步地降低此开销。</span><span class="sxs-lookup"><span data-stu-id="900af-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="900af-146">有关具体示例， [请参阅此基准，此基准](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) 设置具有7类型层次结构的简单模型;5000行是每个累计35000行的种子，而基准只是从数据库加载所有行：</span><span class="sxs-lookup"><span data-stu-id="900af-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="900af-147">方法</span><span class="sxs-lookup"><span data-stu-id="900af-147">Method</span></span> |     <span data-ttu-id="900af-148">平均值</span><span class="sxs-lookup"><span data-stu-id="900af-148">Mean</span></span> |   <span data-ttu-id="900af-149">错误</span><span class="sxs-lookup"><span data-stu-id="900af-149">Error</span></span> |  <span data-ttu-id="900af-150">标准偏差</span><span class="sxs-lookup"><span data-stu-id="900af-150">StdDev</span></span> |     <span data-ttu-id="900af-151">第0代</span><span class="sxs-lookup"><span data-stu-id="900af-151">Gen 0</span></span> |     <span data-ttu-id="900af-152">第1代</span><span class="sxs-lookup"><span data-stu-id="900af-152">Gen 1</span></span> |     <span data-ttu-id="900af-153">第2代</span><span class="sxs-lookup"><span data-stu-id="900af-153">Gen 2</span></span> | <span data-ttu-id="900af-154">已分配</span><span class="sxs-lookup"><span data-stu-id="900af-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="900af-155">TPH</span><span class="sxs-lookup"><span data-stu-id="900af-155">TPH</span></span> | <span data-ttu-id="900af-156">132.3 ms</span><span class="sxs-lookup"><span data-stu-id="900af-156">132.3 ms</span></span> | <span data-ttu-id="900af-157">2.29 ms</span><span class="sxs-lookup"><span data-stu-id="900af-157">2.29 ms</span></span> | <span data-ttu-id="900af-158">2.03 ms</span><span class="sxs-lookup"><span data-stu-id="900af-158">2.03 ms</span></span> | <span data-ttu-id="900af-159">8000.0000</span><span class="sxs-lookup"><span data-stu-id="900af-159">8000.0000</span></span> | <span data-ttu-id="900af-160">3000.0000</span><span class="sxs-lookup"><span data-stu-id="900af-160">3000.0000</span></span> | <span data-ttu-id="900af-161">1250.0000</span><span class="sxs-lookup"><span data-stu-id="900af-161">1250.0000</span></span> |  <span data-ttu-id="900af-162">44.49 MB</span><span class="sxs-lookup"><span data-stu-id="900af-162">44.49 MB</span></span> |
|    <span data-ttu-id="900af-163">TPT</span><span class="sxs-lookup"><span data-stu-id="900af-163">TPT</span></span> | <span data-ttu-id="900af-164">201.3 ms</span><span class="sxs-lookup"><span data-stu-id="900af-164">201.3 ms</span></span> | <span data-ttu-id="900af-165">3.32 ms</span><span class="sxs-lookup"><span data-stu-id="900af-165">3.32 ms</span></span> | <span data-ttu-id="900af-166">3.10 ms</span><span class="sxs-lookup"><span data-stu-id="900af-166">3.10 ms</span></span> | <span data-ttu-id="900af-167">9000.0000</span><span class="sxs-lookup"><span data-stu-id="900af-167">9000.0000</span></span> | <span data-ttu-id="900af-168">4000.0000</span><span class="sxs-lookup"><span data-stu-id="900af-168">4000.0000</span></span> |         - |  <span data-ttu-id="900af-169">61.84 MB</span><span class="sxs-lookup"><span data-stu-id="900af-169">61.84 MB</span></span> |

<span data-ttu-id="900af-170">正如您所见，对于这种情况，TPH 比 TPT 的效率更高。</span><span class="sxs-lookup"><span data-stu-id="900af-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="900af-171">请注意，实际结果始终取决于所执行的特定查询和层次结构中的表数，因此其他查询可能会显示不同的性能差距;建议使用此基准代码作为模板来测试其他查询。</span><span class="sxs-lookup"><span data-stu-id="900af-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
