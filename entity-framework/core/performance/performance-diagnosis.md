---
title: 性能诊断-EF Core
description: 诊断 Entity Framework Core 性能并识别瓶颈
author: roji
ms.date: 12/1/2020
uid: core/performance/performance-diagnosis
ms.openlocfilehash: 9416acf3326056ef7a5d732c4bd456dac751167b
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657707"
---
# <a name="performance-diagnosis"></a><span data-ttu-id="13e7d-103">性能诊断</span><span class="sxs-lookup"><span data-stu-id="13e7d-103">Performance Diagnosis</span></span>

<span data-ttu-id="13e7d-104">本部分讨论检测 EF 应用程序中的性能问题的方法，并在确定有问题的区域后，如何进一步分析它们以确定根本问题。</span><span class="sxs-lookup"><span data-stu-id="13e7d-104">This section discusses ways for detecting performance issues in your EF application, and once a problematic area has been identified, how to further analyze them to identify the root problem.</span></span> <span data-ttu-id="13e7d-105">在跳转到任何结论之前，请务必仔细诊断并调查任何问题，以避免假设问题的根源。</span><span class="sxs-lookup"><span data-stu-id="13e7d-105">It's important to carefully diagnose and investigate any problems before jumping to any conclusions, and to avoid assuming where the root of the issue is.</span></span>

## <a name="identifying-slow-database-commands-via-logging"></a><span data-ttu-id="13e7d-106">通过日志记录标识慢速数据库命令</span><span class="sxs-lookup"><span data-stu-id="13e7d-106">Identifying slow database commands via logging</span></span>

<span data-ttu-id="13e7d-107">在一天结束时，EF 将准备并执行要对数据库执行的命令;对于关系数据库，这意味着通过 ADO.NET 数据库 API 执行 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="13e7d-107">At the end of the day, EF prepares and executes commands to be executed against your database; with relational database, that means executing SQL statements via the ADO.NET database API.</span></span> <span data-ttu-id="13e7d-108">如果某个查询所花的时间太长 (例如，因为缺少索引) ，则可以通过检查命令执行日志并观察它们实际执行的时间来发现。</span><span class="sxs-lookup"><span data-stu-id="13e7d-108">If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take.</span></span>

<span data-ttu-id="13e7d-109">EF 使你可以通过 [简单日志记录](xref:core/logging-events-diagnostics/simple-logging) 或 Microsoft 来轻松地捕获命令执行时间 [。日志记录](xref:core/logging-events-diagnostics/extensions-logging)：</span><span class="sxs-lookup"><span data-stu-id="13e7d-109">EF makes it very easy to capture command execution times, via either [simple logging](xref:core/logging-events-diagnostics/simple-logging) or [Microsoft.Extensions.Logging](xref:core/logging-events-diagnostics/extensions-logging):</span></span>

### <a name="simple-logging"></a>[<span data-ttu-id="13e7d-110">简单的日志记录</span><span class="sxs-lookup"><span data-stu-id="13e7d-110">Simple logging</span></span>](#tab/simple-logging)

[!code-csharp[Main](../../../samples/core/Performance/BloggingContext.cs#SimpleLogging)]

### <a name="microsoftextensionslogging"></a>[<span data-ttu-id="13e7d-111">Microsoft.Extensions.Logging</span><span class="sxs-lookup"><span data-stu-id="13e7d-111">Microsoft.Extensions.Logging</span></span>](#tab/microsoft-extensions-logging)

[!code-csharp[Main](../../../samples/core/Performance/ExtensionsLoggingContext.cs#ExtensionsLogging)]

***

<span data-ttu-id="13e7d-112">如果日志记录级别设置为 `LogLevel.Information` ，则 EF 会使用所用时间为每个命令执行发出一条日志消息：</span><span class="sxs-lookup"><span data-stu-id="13e7d-112">When the logging level is set at `LogLevel.Information`, EF emits a log message for each command execution with the time taken:</span></span>

```log
info: 06/12/2020 09:12:36.117 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command)
      Executed DbCommand (4ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[Id], [b].[Name]
      FROM [Blogs] AS [b]
      WHERE [b].[Name] = N'foo'
```

<span data-ttu-id="13e7d-113">上述命令花费了4毫秒。</span><span class="sxs-lookup"><span data-stu-id="13e7d-113">The above command took 4 milliseconds.</span></span> <span data-ttu-id="13e7d-114">如果某个命令的执行时间超过预期，则可能是由于性能问题而发现可能的问题，现在可以集中精力来了解它运行缓慢的原因。</span><span class="sxs-lookup"><span data-stu-id="13e7d-114">If a certain command takes more than expected, you've found a possible culprit for a performance issue, and can now focus on it to understand why it's running slowly.</span></span> <span data-ttu-id="13e7d-115">命令日志记录还可以揭示发生意外的数据库往返的情况;这会显示为多个只需要一个命令的命令。</span><span class="sxs-lookup"><span data-stu-id="13e7d-115">Command logging can also reveal cases where unexpected database roundtrips are being made; this would show up as multiple commands where only one is expected.</span></span>

> [!WARNING]
> <span data-ttu-id="13e7d-116">在生产环境中启用命令执行日志记录通常是一种不好的做法。</span><span class="sxs-lookup"><span data-stu-id="13e7d-116">Leaving command execution logging enabled in your production environment is usually a bad idea.</span></span> <span data-ttu-id="13e7d-117">日志记录本身会降低应用程序的速度，并可快速创建大量日志文件，从而填满服务器的磁盘空间。</span><span class="sxs-lookup"><span data-stu-id="13e7d-117">The logging itself slows down your application, and may quickly create huge log files which can fill up your server's disk.</span></span> <span data-ttu-id="13e7d-118">建议只将日志记录时间缩短为收集数据的时间间隔，同时仔细监视应用程序或捕获预生产系统上的日志记录数据。</span><span class="sxs-lookup"><span data-stu-id="13e7d-118">It's recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring your application - or to capture logging data on a pre-production system.</span></span>

## <a name="correlating-database-commands-to-linq-queries"></a><span data-ttu-id="13e7d-119">将数据库命令关联到 LINQ 查询</span><span class="sxs-lookup"><span data-stu-id="13e7d-119">Correlating database commands to LINQ queries</span></span>

<span data-ttu-id="13e7d-120">命令执行日志记录的一个问题是，有时很难关联 SQL 查询和 LINQ 查询： EF 执行的 SQL 命令可能与生成它们的 LINQ 查询看起来非常不同。</span><span class="sxs-lookup"><span data-stu-id="13e7d-120">One problem with command execution logging is that it's sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated.</span></span> <span data-ttu-id="13e7d-121">为了帮助解决此问题，你可能需要使用 EF 的 " [查询标记](xref:core/querying/tags) " 功能，该功能允许你将一个小型的标识注释注入到 SQL 查询中：</span><span class="sxs-lookup"><span data-stu-id="13e7d-121">To help with this difficulty, you may want to use EF's [query tags](xref:core/querying/tags) feature, which allows you to inject a small, identifying comment into the SQL query:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tags/Program.cs#BasicQueryTag)]

<span data-ttu-id="13e7d-122">此标记显示在日志中：</span><span class="sxs-lookup"><span data-stu-id="13e7d-122">The tag shows up in the logs:</span></span>

```sql
-- This is my spatial query!

SELECT TOP(@__p_1) [p].[Id], [p].[Location]
FROM [People] AS [p]
ORDER BY [p].[Location].STDistance(@__myLocation_0) DESC
```

<span data-ttu-id="13e7d-123">通常，使用这种方法标记应用程序的主要查询会使命令执行日志的可读性更高。</span><span class="sxs-lookup"><span data-stu-id="13e7d-123">It's often worth tagging the major queries of an application in this way, to make the command execution logs more immediately readable.</span></span>

## <a name="other-interfaces-for-capturing-performance-data"></a><span data-ttu-id="13e7d-124">用于捕获性能数据的其他接口</span><span class="sxs-lookup"><span data-stu-id="13e7d-124">Other interfaces for capturing performance data</span></span>

<span data-ttu-id="13e7d-125">EF 的日志记录功能有多种替代方法，用于捕获命令执行时间，这可能更加强大。</span><span class="sxs-lookup"><span data-stu-id="13e7d-125">There are various alternatives to EF's logging feature for capturing command execution times, which may be more powerful.</span></span> <span data-ttu-id="13e7d-126">数据库通常附带自己的跟踪和性能分析工具，这些工具通常提供比简单的执行时间更丰富的数据库特定的信息;每个数据库的实际设置、功能和使用情况各不相同。</span><span class="sxs-lookup"><span data-stu-id="13e7d-126">Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases.</span></span>

<span data-ttu-id="13e7d-127">例如， [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) 是一种功能强大的客户端，可连接到 SQL Server 实例，并提供有价值的管理和性能信息。</span><span class="sxs-lookup"><span data-stu-id="13e7d-127">For example, [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) is a powerful client that can connect to your SQL Server  instance and provide valuable management and performance information.</span></span> <span data-ttu-id="13e7d-128">此部分超出了详细信息的范围，但有两个值得提的功能是 [活动监视器](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio)，它提供了服务器活动的实时仪表板， (包括最昂贵的查询) 和 [扩展事件 (XEvent) ](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server) 功能，这允许定义可根据你的确切需求进行定制的任意数据捕获会话。</span><span class="sxs-lookup"><span data-stu-id="13e7d-128">It's beyond the scope of this section to go into the details, but two capabilities worth mentioning are the [Activity Monitor](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio), which provides a live dashboard of server activity (including the most expensive queries), and the [Extended Events (XEvent)](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server) feature, which allows defining arbitrary data capture sessions which can be tailored to your exact needs.</span></span> <span data-ttu-id="13e7d-129">[有关监视的 SQL Server 文档](/sql/relational-databases/performance/monitor-and-tune-for-performance) 提供了有关这些功能以及其他功能的详细信息。</span><span class="sxs-lookup"><span data-stu-id="13e7d-129">[The SQL Server documentation on monitoring](/sql/relational-databases/performance/monitor-and-tune-for-performance) provides more information on these features, as well as others.</span></span>

<span data-ttu-id="13e7d-130">捕获性能数据的另一种方法是，通过接口收集由 EF 或数据库驱动程序自动发出的信息 `DiagnosticSource` ，然后分析该数据或将其显示在仪表板上。</span><span class="sxs-lookup"><span data-stu-id="13e7d-130">Another approach for capturing performance data is to collect information automatically emitted by either EF or the database driver via the `DiagnosticSource` interface, and then analyze that data or display it on a dashboard.</span></span> <span data-ttu-id="13e7d-131">如果你使用的是 Azure，则 [Azure 应用程序 Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) 提供现成的强大监视功能，从而在分析你的 web 请求的速度时，集成数据库性能和查询执行时间。</span><span class="sxs-lookup"><span data-stu-id="13e7d-131">If you are using Azure, then [Azure Application Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) provides such powerful monitoring out of the box, integrating database performance and query execution times in the analysis of how quickly your web requests are being served.</span></span> <span data-ttu-id="13e7d-132">有关此功能的详细信息，请访问 [Application Insights 性能教程](/azure/azure-monitor/learn/tutorial-performance)和 [Azure SQL analytics 页面](/azure/azure-monitor/insights/azure-sql)。</span><span class="sxs-lookup"><span data-stu-id="13e7d-132">More information on this is available in the [Application Insights performance tutorial](/azure/azure-monitor/learn/tutorial-performance), and in the [Azure SQL analytics page](/azure/azure-monitor/insights/azure-sql).</span></span>

## <a name="inspecting-query-execution-plans"></a><span data-ttu-id="13e7d-133">检查查询执行计划</span><span class="sxs-lookup"><span data-stu-id="13e7d-133">Inspecting query execution plans</span></span>

<span data-ttu-id="13e7d-134">在您查明了需要优化的问题查询后，下一步通常是分析查询的 *执行计划*。</span><span class="sxs-lookup"><span data-stu-id="13e7d-134">Once you've pinpointed a problematic query that requires optimization, the next step is usually analyzing the query's *execution plan*.</span></span> <span data-ttu-id="13e7d-135">当数据库收到 SQL 语句时，它们通常会生成计划的执行方式，这有时需要根据已定义的索引、表中存在的数据量等来做出复杂的决策， (顺便说一下，计划本身应缓存在服务器上，以获得最佳性能) 。</span><span class="sxs-lookup"><span data-stu-id="13e7d-135">When databases receive a SQL statement, they typically produce a plan of how that plan is to be executed; this sometimes requires complicated decision-making based on which indexes have been defined, how much data exists in tables, etc. (incidentally, the plan itself should usually be cached at the server for optimal performance).</span></span> <span data-ttu-id="13e7d-136">关系数据库通常为用户提供了一种方式来查看查询计划，以及查询的不同部分的计算成本;这对于改进查询非常有用。</span><span class="sxs-lookup"><span data-stu-id="13e7d-136">Relational databases typically provide a way for users to see the query plan, along with calculated costing for different parts of the query; this is invaluable for improving your queries.</span></span>

<span data-ttu-id="13e7d-137">若要开始 SQL Server，请参阅有关 [查询执行计划](/sql/relational-databases/performance/execution-plans)的文档。</span><span class="sxs-lookup"><span data-stu-id="13e7d-137">To get started on SQL Server, see the documentation on [query execution plans](/sql/relational-databases/performance/execution-plans).</span></span> <span data-ttu-id="13e7d-138">典型的分析工作流将使用 [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan)，粘贴通过上述方法之一标识的慢速查询的 SQL，并 [生成图形执行计划](/sql/relational-databases/performance/display-an-actual-execution-plan)：</span><span class="sxs-lookup"><span data-stu-id="13e7d-138">The typical analysis workflow would be to use [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan), pasting the SQL of a slow query identified via one of the means above, and [producing a graphical execution plan](/sql/relational-databases/performance/display-an-actual-execution-plan):</span></span>

![显示 SQL Server 执行计划](_static/actualexecplan.png)

<span data-ttu-id="13e7d-140">尽管执行计划在最初看起来很复杂，但一定要花费很长时间来熟悉它们。</span><span class="sxs-lookup"><span data-stu-id="13e7d-140">While execution plans may seem complicated at first, it's worth spending a bit of time getting familiar with them.</span></span> <span data-ttu-id="13e7d-141">尤其重要的是，请注意与计划的每个节点关联的成本，并确定如何在不同节点 (或不) 使用索引。</span><span class="sxs-lookup"><span data-stu-id="13e7d-141">It's particularly important to note the costs associated with each node of the plan, and to identify how indexes are used (or not) in the various nodes.</span></span>

<span data-ttu-id="13e7d-142">虽然以上信息特定于 SQL Server，但其他数据库通常提供与可视化效果相同的工具。</span><span class="sxs-lookup"><span data-stu-id="13e7d-142">While the above information is specific to SQL Server, other databases typically provide the same kind of tools with similar visualization.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13e7d-143">根据数据库中的实际数据，数据库有时会生成不同的查询计划。</span><span class="sxs-lookup"><span data-stu-id="13e7d-143">Databases sometimes generate different query plans depending on actual data in the database.</span></span> <span data-ttu-id="13e7d-144">例如，如果表只包含几行，则数据库可以选择不使用该表的索引，而是改为执行全表扫描。</span><span class="sxs-lookup"><span data-stu-id="13e7d-144">For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead.</span></span> <span data-ttu-id="13e7d-145">如果在测试数据库中分析查询计划，请始终确保它包含类似于生产系统的数据。</span><span class="sxs-lookup"><span data-stu-id="13e7d-145">If analyzing query plans on a test database, always make sure it contains data that is similar to your production system.</span></span>

## <a name="event-counters"></a><span data-ttu-id="13e7d-146">事件计数器</span><span class="sxs-lookup"><span data-stu-id="13e7d-146">Event counters</span></span>

<span data-ttu-id="13e7d-147">以上章节重点介绍如何获取有关命令的信息，以及如何在数据库中执行这些命令。</span><span class="sxs-lookup"><span data-stu-id="13e7d-147">The above sections focused on how to get information about your commands, and how these commands are executed in the database.</span></span> <span data-ttu-id="13e7d-148">除此之外，EF 还公开了一组 *事件计数器* ，这些计数器提供有关在 EF 本身内发生的情况以及应用程序使用它的方式的更低级别信息。</span><span class="sxs-lookup"><span data-stu-id="13e7d-148">In addition to that, EF exposes a set of *event counters* which provide more lower-level information on what's happening inside EF itself, and how your application is using it.</span></span> <span data-ttu-id="13e7d-149">这些计数器对于诊断特定性能问题和性能异常非常有用，例如导致进行持续重新编译的 [查询缓存问题](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) 、未释放 DbContext 和其他计数器。</span><span class="sxs-lookup"><span data-stu-id="13e7d-149">These counters can be very useful for diagnosing specific performance issues and performance anomalies, such as [query caching issues](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) which cause constant recompilation, undisposed DbContext leaks, and others.</span></span>

<span data-ttu-id="13e7d-150">有关详细信息，请参阅 [EF 的事件计数器](xref:core/logging-events-diagnostics/event-counters) 上的专用页面。</span><span class="sxs-lookup"><span data-stu-id="13e7d-150">See the dedicated page on [EF's event counters](xref:core/logging-events-diagnostics/event-counters) for more information.</span></span>

## <a name="benchmarking-with-ef-core"></a><span data-ttu-id="13e7d-151">EF Core 的基准测试</span><span class="sxs-lookup"><span data-stu-id="13e7d-151">Benchmarking with EF Core</span></span>

<span data-ttu-id="13e7d-152">在一天结束时，有时需要知道编写或执行查询的特定方式是否比另一种方法更快。</span><span class="sxs-lookup"><span data-stu-id="13e7d-152">At the end of the day, you sometimes need to know whether a particular way of writing or executing a query is faster than another.</span></span> <span data-ttu-id="13e7d-153">一定要永远不要假设或推测答案，同时将快速基准组合到一起以获得答案非常简单。</span><span class="sxs-lookup"><span data-stu-id="13e7d-153">It's important to never assume or speculate the answer, and it's extremely easy to put together a quick benchmark to get the answer.</span></span> <span data-ttu-id="13e7d-154">编写基准时，强烈建议使用众所周知的 [BenchmarkDotNet](https://benchmarkdotnet.org/index.html) 库，此库处理用户在尝试编写自己的基准时遇到的许多缺陷：是否已执行一些预热迭代？</span><span class="sxs-lookup"><span data-stu-id="13e7d-154">When writing benchmarks, it's strongly recommended to use the well-known [BenchmarkDotNet](https://benchmarkdotnet.org/index.html) library, which handles many pitfalls users encounter when trying to write their own benchmarks: have you performed some warmup iterations?</span></span> <span data-ttu-id="13e7d-155">基准测试实际运行了多少次？</span><span class="sxs-lookup"><span data-stu-id="13e7d-155">How many iterations does your benchmark actually run, and why?</span></span> <span data-ttu-id="13e7d-156">让我们看看 EF Core 的基准的外观。</span><span class="sxs-lookup"><span data-stu-id="13e7d-156">Let's take a look at what a benchmark with EF Core looks like.</span></span>

> [!TIP]
> <span data-ttu-id="13e7d-157">[下面提供了](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)下面的源的完整基准项目。</span><span class="sxs-lookup"><span data-stu-id="13e7d-157">The full benchmark project for the source below is available [here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs).</span></span> <span data-ttu-id="13e7d-158">建议你复制它，并将其用作模板来实现你自己的基准测试。</span><span class="sxs-lookup"><span data-stu-id="13e7d-158">You are encouraged to copy it and use it as a template for your own benchmarks.</span></span>

<span data-ttu-id="13e7d-159">作为一个简单的基准方案，让我们比较一下计算数据库中所有博客的平均排名的不同方法：</span><span class="sxs-lookup"><span data-stu-id="13e7d-159">As a simple benchmark scenario, let's compare the following different methods of calculating the average ranking of all Blogs in our database:</span></span>

* <span data-ttu-id="13e7d-160">加载所有实体，对其各个排名求和，并计算平均值。</span><span class="sxs-lookup"><span data-stu-id="13e7d-160">Load all entities, sum up their individual rankings, and calculate the average.</span></span>
* <span data-ttu-id="13e7d-161">与上面相同，只使用非跟踪查询。</span><span class="sxs-lookup"><span data-stu-id="13e7d-161">The same as above, only use a non-tracking query.</span></span> <span data-ttu-id="13e7d-162">这应该更快，因为不执行标识解析，并且由于更改跟踪目的而不会对实体进行快照。</span><span class="sxs-lookup"><span data-stu-id="13e7d-162">This should be faster, since identity resolution isn't performed, and the entities aren't snapshotted for the purposes of change tracking.</span></span>
* <span data-ttu-id="13e7d-163">通过仅投影排名，避免加载整个博客实体实例。</span><span class="sxs-lookup"><span data-stu-id="13e7d-163">Avoid loading the entire Blog entity instances at all, by projecting out the ranking only.</span></span> <span data-ttu-id="13e7d-164">这使我们无法转移其他不需要的博客实体类型列。</span><span class="sxs-lookup"><span data-stu-id="13e7d-164">The saves us from transferring the other, unneeded columns of the Blog entity type.</span></span>
* <span data-ttu-id="13e7d-165">通过使其成为查询的一部分来计算数据库中的平均值。</span><span class="sxs-lookup"><span data-stu-id="13e7d-165">Calculate the average in the database by making it part of the query.</span></span> <span data-ttu-id="13e7d-166">这应该是最快的方法，因为所有内容都是在数据库中计算的，并且只会将结果传输回客户端。</span><span class="sxs-lookup"><span data-stu-id="13e7d-166">This should be the fastest way, since everything is calculated in the database and only the result is transferred back to the client.</span></span>

<span data-ttu-id="13e7d-167">使用 BenchmarkDotNet，可以编写要作为简单方法（就像单元测试一样）进行基准处理的代码，并且 BenchmarkDotNet 会自动运行每个方法来获得足够的迭代数，并可靠地度量所需的时间和分配的内存量。</span><span class="sxs-lookup"><span data-stu-id="13e7d-167">With BenchmarkDotNet, you write the code to be benchmarked as a simple method - just like a unit test - and BenchmarkDotNet automatically runs each method for sufficient number of iterations, reliably measuring how long it takes and how much memory is allocated.</span></span> <span data-ttu-id="13e7d-168">下面是 ([完整基准代码](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs) 的不同方法) ：</span><span class="sxs-lookup"><span data-stu-id="13e7d-168">Here are the different method ([the full benchmark code can be seen here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)):</span></span>

### <a name="load-entities"></a>[<span data-ttu-id="13e7d-169">加载实体</span><span class="sxs-lookup"><span data-stu-id="13e7d-169">Load entities</span></span>](#tab/load-entities)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntities)]

### <a name="load-entities-no-tracking"></a>[<span data-ttu-id="13e7d-170">加载实体，无跟踪</span><span class="sxs-lookup"><span data-stu-id="13e7d-170">Load entities, no tracking</span></span>](#tab/load-entities-no-tracking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntitiesNoTracking)]

### <a name="project-only-ranking"></a>[<span data-ttu-id="13e7d-171">仅限项目排名</span><span class="sxs-lookup"><span data-stu-id="13e7d-171">Project only ranking</span></span>](#tab/project-only-ranking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=ProjectOnlyRanking)]

### <a name="calculate-in-database"></a>[<span data-ttu-id="13e7d-172">在数据库中计算</span><span class="sxs-lookup"><span data-stu-id="13e7d-172">Calculate in database</span></span>](#tab/calculate-in-database)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=CalculateInDatabase)]

***

<span data-ttu-id="13e7d-173">结果如下所示：</span><span class="sxs-lookup"><span data-stu-id="13e7d-173">The results are below, as printed by BenchmarkDotNet:</span></span>

|                 <span data-ttu-id="13e7d-174">方法</span><span class="sxs-lookup"><span data-stu-id="13e7d-174">Method</span></span> |       <span data-ttu-id="13e7d-175">平均值</span><span class="sxs-lookup"><span data-stu-id="13e7d-175">Mean</span></span> |    <span data-ttu-id="13e7d-176">错误</span><span class="sxs-lookup"><span data-stu-id="13e7d-176">Error</span></span> |   <span data-ttu-id="13e7d-177">标准偏差</span><span class="sxs-lookup"><span data-stu-id="13e7d-177">StdDev</span></span> |     <span data-ttu-id="13e7d-178">中值</span><span class="sxs-lookup"><span data-stu-id="13e7d-178">Median</span></span> | <span data-ttu-id="13e7d-179">比率</span><span class="sxs-lookup"><span data-stu-id="13e7d-179">Ratio</span></span> | <span data-ttu-id="13e7d-180">RatioSD</span><span class="sxs-lookup"><span data-stu-id="13e7d-180">RatioSD</span></span> |    <span data-ttu-id="13e7d-181">第0代</span><span class="sxs-lookup"><span data-stu-id="13e7d-181">Gen 0</span></span> |   <span data-ttu-id="13e7d-182">第1代</span><span class="sxs-lookup"><span data-stu-id="13e7d-182">Gen 1</span></span> | <span data-ttu-id="13e7d-183">第2代</span><span class="sxs-lookup"><span data-stu-id="13e7d-183">Gen 2</span></span> |  <span data-ttu-id="13e7d-184">已分配</span><span class="sxs-lookup"><span data-stu-id="13e7d-184">Allocated</span></span> |
|----------------------- |-----------:|---------:|---------:|-----------:|------:|--------:|---------:|--------:|------:|-----------:|
|           <span data-ttu-id="13e7d-185">LoadEntities</span><span class="sxs-lookup"><span data-stu-id="13e7d-185">LoadEntities</span></span> | <span data-ttu-id="13e7d-186">2860.4 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-186">2,860.4 us</span></span> | <span data-ttu-id="13e7d-187">54.31 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-187">54.31 us</span></span> | <span data-ttu-id="13e7d-188">93.68 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-188">93.68 us</span></span> | <span data-ttu-id="13e7d-189">2844.5 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-189">2,844.5 us</span></span> |  <span data-ttu-id="13e7d-190">4.55</span><span class="sxs-lookup"><span data-stu-id="13e7d-190">4.55</span></span> |    <span data-ttu-id="13e7d-191">0.33</span><span class="sxs-lookup"><span data-stu-id="13e7d-191">0.33</span></span> | <span data-ttu-id="13e7d-192">210.9375</span><span class="sxs-lookup"><span data-stu-id="13e7d-192">210.9375</span></span> | <span data-ttu-id="13e7d-193">70.3125</span><span class="sxs-lookup"><span data-stu-id="13e7d-193">70.3125</span></span> |     - | <span data-ttu-id="13e7d-194">1309.56 KB</span><span class="sxs-lookup"><span data-stu-id="13e7d-194">1309.56 KB</span></span> |
| <span data-ttu-id="13e7d-195">LoadEntitiesNoTracking</span><span class="sxs-lookup"><span data-stu-id="13e7d-195">LoadEntitiesNoTracking</span></span> | <span data-ttu-id="13e7d-196">1353.0 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-196">1,353.0 us</span></span> | <span data-ttu-id="13e7d-197">21.26 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-197">21.26 us</span></span> | <span data-ttu-id="13e7d-198">18.85 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-198">18.85 us</span></span> | <span data-ttu-id="13e7d-199">1355.6 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-199">1,355.6 us</span></span> |  <span data-ttu-id="13e7d-200">2.10</span><span class="sxs-lookup"><span data-stu-id="13e7d-200">2.10</span></span> |    <span data-ttu-id="13e7d-201">0.14</span><span class="sxs-lookup"><span data-stu-id="13e7d-201">0.14</span></span> |  <span data-ttu-id="13e7d-202">87.8906</span><span class="sxs-lookup"><span data-stu-id="13e7d-202">87.8906</span></span> |  <span data-ttu-id="13e7d-203">3.9063</span><span class="sxs-lookup"><span data-stu-id="13e7d-203">3.9063</span></span> |     - |  <span data-ttu-id="13e7d-204">540.09 KB</span><span class="sxs-lookup"><span data-stu-id="13e7d-204">540.09 KB</span></span> |
|     <span data-ttu-id="13e7d-205">ProjectOnlyRanking</span><span class="sxs-lookup"><span data-stu-id="13e7d-205">ProjectOnlyRanking</span></span> |   <span data-ttu-id="13e7d-206">910.9 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-206">910.9 us</span></span> | <span data-ttu-id="13e7d-207">20.91 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-207">20.91 us</span></span> | <span data-ttu-id="13e7d-208">61.65 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-208">61.65 us</span></span> |   <span data-ttu-id="13e7d-209">892.9 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-209">892.9 us</span></span> |  <span data-ttu-id="13e7d-210">1.46</span><span class="sxs-lookup"><span data-stu-id="13e7d-210">1.46</span></span> |    <span data-ttu-id="13e7d-211">0.14</span><span class="sxs-lookup"><span data-stu-id="13e7d-211">0.14</span></span> |  <span data-ttu-id="13e7d-212">41.0156</span><span class="sxs-lookup"><span data-stu-id="13e7d-212">41.0156</span></span> |  <span data-ttu-id="13e7d-213">0.9766</span><span class="sxs-lookup"><span data-stu-id="13e7d-213">0.9766</span></span> |     - |  <span data-ttu-id="13e7d-214">252.08 KB</span><span class="sxs-lookup"><span data-stu-id="13e7d-214">252.08 KB</span></span> |
|    <span data-ttu-id="13e7d-215">CalculateInDatabase</span><span class="sxs-lookup"><span data-stu-id="13e7d-215">CalculateInDatabase</span></span> |   <span data-ttu-id="13e7d-216">627.1 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-216">627.1 us</span></span> | <span data-ttu-id="13e7d-217">14.58 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-217">14.58 us</span></span> | <span data-ttu-id="13e7d-218">42.54 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-218">42.54 us</span></span> |   <span data-ttu-id="13e7d-219">626.4 美国</span><span class="sxs-lookup"><span data-stu-id="13e7d-219">626.4 us</span></span> |  <span data-ttu-id="13e7d-220">1.00</span><span class="sxs-lookup"><span data-stu-id="13e7d-220">1.00</span></span> |    <span data-ttu-id="13e7d-221">0.00</span><span class="sxs-lookup"><span data-stu-id="13e7d-221">0.00</span></span> |   <span data-ttu-id="13e7d-222">4.8828</span><span class="sxs-lookup"><span data-stu-id="13e7d-222">4.8828</span></span> |       - |     - |   <span data-ttu-id="13e7d-223">33.27 KB</span><span class="sxs-lookup"><span data-stu-id="13e7d-223">33.27 KB</span></span> |

> [!NOTE]
> <span data-ttu-id="13e7d-224">当方法在方法中实例化和释放上下文时，将对这些操作进行计算，而不是查询过程的一部分。</span><span class="sxs-lookup"><span data-stu-id="13e7d-224">As the methods instantiate and dispose the context within the method, these operations are counted for the benchmark, although strictly speaking they are not part of the querying process.</span></span> <span data-ttu-id="13e7d-225">如果目标是将两种替代方法与另一个 (进行比较，则这一点不重要，因为上下文实例化和处置都是相同的) ，并为整个操作提供更全面的度量。</span><span class="sxs-lookup"><span data-stu-id="13e7d-225">This should not matter if the goal is to compare two alternatives to one another (since the context instantiation and disposal are the same), and gives a more holistic measurement for the entire operation.</span></span>

<span data-ttu-id="13e7d-226">BenchmarkDotNet 的一个限制是，它测量你所提供的方法的简单的单线程性能，因此不太适合用于基准并发方案。</span><span class="sxs-lookup"><span data-stu-id="13e7d-226">One limitation of BenchmarkDotNet is that it measures simple, single-thread performance of the methods you provide, and is therefore not well-suited for benchmarking concurrent scenarios.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13e7d-227">请始终确保在进行基准测试时数据库中的数据与生产数据相似，否则基准测试结果可能不表示生产中的实际性能。</span><span class="sxs-lookup"><span data-stu-id="13e7d-227">Always make sure to have data in your database that is similar to production data when benchmarking, otherwise the benchmark results may not represent actual performance in production.</span></span>
