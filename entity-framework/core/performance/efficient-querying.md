---
title: 高效查询-EF Core
description: 使用 Entity Framework Core 高效查询的性能指南
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: e945a1e0f734d62ce8948904bcbe819455fcbefa
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128480"
---
# <a name="efficient-querying"></a><span data-ttu-id="da668-103">高效查询</span><span class="sxs-lookup"><span data-stu-id="da668-103">Efficient Querying</span></span>

<span data-ttu-id="da668-104">有效地进行查询是一种广泛的主题，涵盖作为索引、相关实体加载策略以及许多其他主题的主体。</span><span class="sxs-lookup"><span data-stu-id="da668-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="da668-105">本部分详细介绍了一些用于更快地进行查询的常见主题，以及用户通常会遇到的问题。</span><span class="sxs-lookup"><span data-stu-id="da668-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="da668-106">正确使用索引</span><span class="sxs-lookup"><span data-stu-id="da668-106">Use indexes properly</span></span>

<span data-ttu-id="da668-107">查询能否快速使用索引的主要决定因素是：数据库通常用于保存大量数据，而遍历整个表的查询通常是严重的性能问题的根源所在。</span><span class="sxs-lookup"><span data-stu-id="da668-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="da668-108">索引问题不太容易发现，因为给定的查询是否将使用索引。</span><span class="sxs-lookup"><span data-stu-id="da668-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="da668-109">例如：</span><span class="sxs-lookup"><span data-stu-id="da668-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="da668-110">发现索引问题的一个好方法是首先查明慢速查询，然后通过数据库的偏好工具检查其查询计划;有关如何执行此操作的详细信息，请参阅 " [性能诊断](xref:core/performance/performance-diagnosis) " 页。</span><span class="sxs-lookup"><span data-stu-id="da668-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="da668-111">查询计划显示查询是遍历整个表，还是使用索引。</span><span class="sxs-lookup"><span data-stu-id="da668-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="da668-112">作为一般规则，没有任何特殊的 EF 知识可用于使用索引或诊断与它们相关的性能问题;与索引相关的一般数据库知识与 EF 应用程序相关，与不使用 EF 的应用程序一样。</span><span class="sxs-lookup"><span data-stu-id="da668-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="da668-113">下表列出了在使用索引时要记住的一些一般准则：</span><span class="sxs-lookup"><span data-stu-id="da668-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="da668-114">尽管索引可以提高查询速度，但它们也会减缓更新，因为它们需要保持最新状态。</span><span class="sxs-lookup"><span data-stu-id="da668-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="da668-115">避免定义不需要的索引，并考虑使用 [索引筛选器](xref:core/modeling/indexes#index-filter) 将索引限制为行的子集，从而减少此开销。</span><span class="sxs-lookup"><span data-stu-id="da668-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="da668-116">复合索引可以加速对多个列进行筛选的查询，但也可以加速不筛选索引的所有列的查询，具体取决于排序。</span><span class="sxs-lookup"><span data-stu-id="da668-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="da668-117">例如，列 A 和列 B 上的索引加快了 A 和 B 筛选查询，并查询仅筛选了筛选器，但它并不能加速仅由 B 进行的查询筛选。</span><span class="sxs-lookup"><span data-stu-id="da668-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="da668-118">如果查询按表达式筛选列 (例如 `price / 2`) ，则无法使用简单索引。</span><span class="sxs-lookup"><span data-stu-id="da668-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="da668-119">但是，您可以为表达式定义 [存储的持久化列](xref:core/modeling/generated-properties#computed-columns) ，并对该列创建索引。</span><span class="sxs-lookup"><span data-stu-id="da668-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="da668-120">某些数据库还支持表达式索引，可以直接使用表达式索引来加快通过任何表达式筛选的查询。</span><span class="sxs-lookup"><span data-stu-id="da668-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="da668-121">不同数据库允许以各种方式配置索引，在许多情况下，EF Core 提供程序通过流畅的 API 公开这些索引。</span><span class="sxs-lookup"><span data-stu-id="da668-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="da668-122">例如，SQL Server 提供程序允许你配置索引是否为 [聚集](xref:core/providers/sql-server/indexes#clustering)索引，或设置其 [填充因子](xref:core/providers/sql-server/indexes#fill-factor)。</span><span class="sxs-lookup"><span data-stu-id="da668-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="da668-123">有关详细信息，请查阅提供商的文档。</span><span class="sxs-lookup"><span data-stu-id="da668-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="da668-124">仅限项目需要的属性</span><span class="sxs-lookup"><span data-stu-id="da668-124">Project only properties you need</span></span>

<span data-ttu-id="da668-125">EF Core 使得查询实体实例变得非常简单，然后在代码中使用这些实例。</span><span class="sxs-lookup"><span data-stu-id="da668-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="da668-126">但是，查询实体实例通常可以从数据库中提取比需要的更多数据。</span><span class="sxs-lookup"><span data-stu-id="da668-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="da668-127">考虑以下情况：</span><span class="sxs-lookup"><span data-stu-id="da668-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="da668-128">尽管此代码实际上只需要每个博客的 `Url` 属性，但会提取整个博客实体，并且不需要的列将从数据库传输：</span><span class="sxs-lookup"><span data-stu-id="da668-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="da668-129">这可以通过使用 `Select` 来告诉 EF 要投影哪些列：</span><span class="sxs-lookup"><span data-stu-id="da668-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="da668-130">生成的 SQL 仅拉取所需的列：</span><span class="sxs-lookup"><span data-stu-id="da668-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="da668-131">如果需要投影多个列，请使用所需的属性投影到 c # 匿名类型。</span><span class="sxs-lookup"><span data-stu-id="da668-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="da668-132">请注意，这种方法对只读查询非常有用，但如果您需要 *更新* 提取的博客，事情会变得更加复杂，因为 EF 的更改跟踪仅适用于实体实例。</span><span class="sxs-lookup"><span data-stu-id="da668-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="da668-133">通过附加修改后的博客实例，并告诉 EF 哪些属性已更改，可以执行更新而无需加载整个实体。</span><span class="sxs-lookup"><span data-stu-id="da668-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="da668-134">限制结果集大小</span><span class="sxs-lookup"><span data-stu-id="da668-134">Limit the resultset size</span></span>

<span data-ttu-id="da668-135">默认情况下，查询将返回与筛选器匹配的所有行：</span><span class="sxs-lookup"><span data-stu-id="da668-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="da668-136">由于返回的行数取决于数据库中的实际数据，因此不可能知道将从数据库中加载的数据量、结果占用的内存量，以及处理这些结果时将生成多少额外负载 (例如，通过网络) 发送到用户浏览器。</span><span class="sxs-lookup"><span data-stu-id="da668-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="da668-137">至关重要，测试数据库经常包含很少的数据，以便在测试时一切都能正常运行，但当查询开始在实际数据上运行并且返回了很多行时，会突然出现性能问题。</span><span class="sxs-lookup"><span data-stu-id="da668-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="da668-138">因此，通常有必要提供限制结果数的考虑：</span><span class="sxs-lookup"><span data-stu-id="da668-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="da668-139">你的 UI 至少可能会显示一条消息，指示数据库中可能存在更多行 (并允许) 的其他方式检索这些行。</span><span class="sxs-lookup"><span data-stu-id="da668-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="da668-140">全面的解决方案将实现 *分页*，其中 UI 一次只显示一定数量的行，并允许用户根据需要转到下一页。这通常会组合 <xref:System.Linq.Enumerable.Take%2A> 和 <xref:System.Linq.Enumerable.Skip%2A> 运算符，以便每次在结果集中选择特定范围。</span><span class="sxs-lookup"><span data-stu-id="da668-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="da668-141">在加载相关实体时避免笛卡尔分解</span><span class="sxs-lookup"><span data-stu-id="da668-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="da668-142">在关系数据库中，所有相关实体通过在单个查询中引入 JOIN 来加载。</span><span class="sxs-lookup"><span data-stu-id="da668-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="da668-143">如果典型博客有多篇相关文章，这些文章对应的行会复制博客的信息。</span><span class="sxs-lookup"><span data-stu-id="da668-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="da668-144">这种复制会导致所谓的“笛卡尔爆炸”问题发生。</span><span class="sxs-lookup"><span data-stu-id="da668-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="da668-145">随着加载更多的一对多关系，重复的数据量可能会增长，并对应用程序性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="da668-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="da668-146">EF 允许使用 "拆分查询" 来避免这种影响，后者通过单独的查询来加载相关实体。</span><span class="sxs-lookup"><span data-stu-id="da668-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="da668-147">有关详细信息，请阅读 [有关拆分和单个查询的文档](xref:core/querying/single-split-queries)。</span><span class="sxs-lookup"><span data-stu-id="da668-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="da668-148">[拆分查询](xref:core/querying/single-split-queries)的当前实现执行每个查询的往返。</span><span class="sxs-lookup"><span data-stu-id="da668-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="da668-149">我们计划在将来改进这一点，并在单次往返中执行所有查询。</span><span class="sxs-lookup"><span data-stu-id="da668-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="da668-150">尽可能积极加载相关实体</span><span class="sxs-lookup"><span data-stu-id="da668-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="da668-151">建议在继续此部分之前，先阅读 [相关实体的专用页面](xref:core/querying/related-data) 。</span><span class="sxs-lookup"><span data-stu-id="da668-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="da668-152">在处理相关实体时，我们通常会提前了解需要加载的内容：典型的示例是加载一组特定的博客以及所有发布内容。</span><span class="sxs-lookup"><span data-stu-id="da668-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="da668-153">在这些情况下，最好使用 [预先加载](xref:core/querying/related-data/eager)，以便 EF 可以在一往返中提取所有必需的数据。</span><span class="sxs-lookup"><span data-stu-id="da668-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="da668-154">EF Core 5.0 中引入的 [筛选的包含](xref:core/querying/related-data/eager#filtered-include) 功能还允许您限制要加载的相关实体，同时使加载过程保持预先，进而可行单个往返：</span><span class="sxs-lookup"><span data-stu-id="da668-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="da668-155">在其他情况下，我们可能不知道我们要在获取其主体实体之前需要哪些相关实体。</span><span class="sxs-lookup"><span data-stu-id="da668-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="da668-156">例如，在加载某些博客时，可能需要咨询其他一些数据源（可能是 webservice），以了解我们是否对该博客文章感兴趣。</span><span class="sxs-lookup"><span data-stu-id="da668-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="da668-157">在这些情况下，可以使用 [显式](xref:core/querying/related-data/explicit) 或 [延迟](xref:core/querying/related-data/lazy) 加载单独提取相关实体，并填充博客的文章导航。</span><span class="sxs-lookup"><span data-stu-id="da668-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="da668-158">请注意，由于这些方法不是预先的，因此需要对数据库进行额外的往返，这是一种缓慢的源;根据具体的方案，只需始终加载所有帖子，而不是执行额外的往返，并有选择地仅获取所需的内容，这种方法可能更高效。</span><span class="sxs-lookup"><span data-stu-id="da668-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="da668-159">注意延迟加载</span><span class="sxs-lookup"><span data-stu-id="da668-159">Beware of lazy loading</span></span>

<span data-ttu-id="da668-160">[延迟加载](xref:core/querying/related-data/lazy) 通常是一种非常有用的方法来编写数据库逻辑，因为 EF Core 在代码访问数据库时，它们会从数据库中自动加载相关实体。</span><span class="sxs-lookup"><span data-stu-id="da668-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="da668-161">这可以避免加载 (（如 [显式加载](xref:core/querying/related-data/explicit)) ）所需的相关实体，似乎使程序员不必处理相关实体。</span><span class="sxs-lookup"><span data-stu-id="da668-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="da668-162">不过，延迟加载特别容易产生不必要的额外往返，这会降低应用程序的速度。</span><span class="sxs-lookup"><span data-stu-id="da668-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="da668-163">考虑以下情况：</span><span class="sxs-lookup"><span data-stu-id="da668-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="da668-164">这种看似合法的代码段会循环访问所有博客及其帖子，打印出来。启用 EF Core 的 [语句日志记录](xref:core/logging-events-diagnostics/index) 会显示以下内容：</span><span class="sxs-lookup"><span data-stu-id="da668-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="da668-165">这是怎么回事？</span><span class="sxs-lookup"><span data-stu-id="da668-165">What's going on here?</span></span> <span data-ttu-id="da668-166">为什么要为上述简单循环发送所有这些查询？</span><span class="sxs-lookup"><span data-stu-id="da668-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="da668-167">使用延迟加载时，博客的张贴内容仅 (延迟) 在访问其 Post 属性时加载;因此，内部 foreach 中的每个迭代都将在其自身的往返中触发附加的数据库查询。</span><span class="sxs-lookup"><span data-stu-id="da668-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="da668-168">因此，在初始查询加载所有博客后，我们会在 *每个博客* 中创建另一个查询，并加载其所有文章;这有时称为 *N + 1* 问题，这可能会导致严重的性能问题。</span><span class="sxs-lookup"><span data-stu-id="da668-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="da668-169">假设我们将需要所有的博客文章，可以改为在此处使用预先加载。</span><span class="sxs-lookup"><span data-stu-id="da668-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="da668-170">我们可以使用 [Include](xref:core/querying/related-data/eager#eager-loading) 运算符来执行加载，但由于我们只需要博客的 url (并且应该只 [加载) 所需的内容](xref:core/performance/efficient-querying#project-only-properties-you-need) 。</span><span class="sxs-lookup"><span data-stu-id="da668-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span></span> <span data-ttu-id="da668-171">我们将改为使用投影：</span><span class="sxs-lookup"><span data-stu-id="da668-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="da668-172">这会使 EF Core 在单个查询中提取所有博客及其帖子。</span><span class="sxs-lookup"><span data-stu-id="da668-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="da668-173">在某些情况下，使用 [拆分查询](xref:core/querying/single-split-queries)来避免笛卡尔分解效果也很有用。</span><span class="sxs-lookup"><span data-stu-id="da668-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="da668-174">由于延迟加载使得无意中触发了 N + 1 问题，因此建议避免出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="da668-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="da668-175">当发生数据库往返时，预先或显式加载会使源代码非常清楚。</span><span class="sxs-lookup"><span data-stu-id="da668-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="da668-176">缓冲和流式处理</span><span class="sxs-lookup"><span data-stu-id="da668-176">Buffering and streaming</span></span>

<span data-ttu-id="da668-177">缓冲是指将所有查询结果加载到内存中，而流式处理意味着 EF 每次都要将应用程序作为单个结果，绝不会将整个结果集包含在内存中。</span><span class="sxs-lookup"><span data-stu-id="da668-177">Buffering refers to loading all your query results into memory, whereas streaming means that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="da668-178">原则上，流式处理查询的内存要求是固定的，无论查询返回1行还是1000，它们都是相同的。另一方面，缓冲查询需要更多的内存来返回更多的行。</span><span class="sxs-lookup"><span data-stu-id="da668-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="da668-179">对于产生大型结果集的查询，这可能是一个重要的性能因素。</span><span class="sxs-lookup"><span data-stu-id="da668-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="da668-180">查询缓冲区或流是否取决于其计算方式：</span><span class="sxs-lookup"><span data-stu-id="da668-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="da668-181">如果查询只返回几个结果，则可能无需担心。</span><span class="sxs-lookup"><span data-stu-id="da668-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="da668-182">但是，如果您的查询可能返回大量的行，则有必要为流式传输而不是缓冲。</span><span class="sxs-lookup"><span data-stu-id="da668-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="da668-183">如果要 <xref:System.Linq.Enumerable.ToList%2A> <xref:System.Linq.Enumerable.ToArray%2A> 在结果中使用另一个 LINQ 运算符，请避免使用或，这将不必要地将所有结果缓冲到内存中。</span><span class="sxs-lookup"><span data-stu-id="da668-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="da668-184">请改用 <xref:System.Linq.Enumerable.AsEnumerable%2A>。</span><span class="sxs-lookup"><span data-stu-id="da668-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="da668-185">EF 的内部缓冲</span><span class="sxs-lookup"><span data-stu-id="da668-185">Internal buffering by EF</span></span>

<span data-ttu-id="da668-186">在某些情况下，无论您对查询的评估方式如何，EF 都会在内部将结果集缓冲。</span><span class="sxs-lookup"><span data-stu-id="da668-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="da668-187">出现这种情况的两种情况是：</span><span class="sxs-lookup"><span data-stu-id="da668-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="da668-188">重试执行策略已准备就绪。</span><span class="sxs-lookup"><span data-stu-id="da668-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="da668-189">这样做是为了确保以后重试查询时返回相同的结果。</span><span class="sxs-lookup"><span data-stu-id="da668-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="da668-190">使用 [split 查询](xref:core/querying/single-split-queries) 时，将缓冲除最后一个查询之外的所有结果，除非在 SQL Server 上启用了 MARS。</span><span class="sxs-lookup"><span data-stu-id="da668-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="da668-191">这是因为通常无法同时激活多个查询结果集。</span><span class="sxs-lookup"><span data-stu-id="da668-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="da668-192">请注意，除通过 LINQ 运算符引起的任何缓冲外，还会发生此内部缓冲。</span><span class="sxs-lookup"><span data-stu-id="da668-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="da668-193">例如，如果在 <xref:System.Linq.Enumerable.ToList%2A> 查询中使用，并且正在重试执行策略，则会将结果集加载到内存中 *两* 次：一次由 EF 提供一次，一次加载 <xref:System.Linq.Enumerable.ToList%2A> 。</span><span class="sxs-lookup"><span data-stu-id="da668-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="da668-194">跟踪，无跟踪和标识解析</span><span class="sxs-lookup"><span data-stu-id="da668-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="da668-195">在继续此部分之前，建议阅读 [有关跟踪和无跟踪的专用页面](xref:core/querying/tracking) 。</span><span class="sxs-lookup"><span data-stu-id="da668-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="da668-196">EF 默认跟踪实体实例，因此在调用时，将会检测并保存对实体实例所做的更改 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> 。</span><span class="sxs-lookup"><span data-stu-id="da668-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="da668-197">跟踪查询的另一个作用是 EF 检测是否已为你的数据加载了一个实例，并将自动返回该跟踪的实例，而不是返回新的实例;这称为 *标识解析*。</span><span class="sxs-lookup"><span data-stu-id="da668-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="da668-198">从性能的角度来看，"更改跟踪" 的含义如下：</span><span class="sxs-lookup"><span data-stu-id="da668-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="da668-199">EF 在内部维护跟踪实例的字典。</span><span class="sxs-lookup"><span data-stu-id="da668-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="da668-200">加载新数据时，EF 会检查字典，以查看是否已为该实体的密钥跟踪了某个实例 (标识解析) 。</span><span class="sxs-lookup"><span data-stu-id="da668-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="da668-201">加载查询结果时，字典维护和查找会花费一些时间。</span><span class="sxs-lookup"><span data-stu-id="da668-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="da668-202">在将加载的实例处理到应用程序之前，将实例 *快照* 并在内部保留快照。</span><span class="sxs-lookup"><span data-stu-id="da668-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="da668-203"><xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>调用时，应用程序的实例与快照进行比较，以发现要保存的更改。</span><span class="sxs-lookup"><span data-stu-id="da668-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="da668-204">快照占用更多内存，快照进程本身需要时间;有时可以通过 [值](xref:core/modeling/value-comparers)比较器指定不同的、可能更有效的快照行为，或使用更改跟踪代理来完全绕过快照进程， (虽然附带了自己的一组缺点) 。</span><span class="sxs-lookup"><span data-stu-id="da668-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="da668-205">在未将更改保存回数据库的只读方案中，可以通过使用 [无跟踪查询](xref:core/querying/tracking#no-tracking-queries)来避免上述开销。</span><span class="sxs-lookup"><span data-stu-id="da668-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="da668-206">但是，因为无跟踪查询不会执行标识解析，所以，由多个其他加载行引用的数据库行将被具体化为不同的实例。</span><span class="sxs-lookup"><span data-stu-id="da668-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as as different instances.</span></span>

<span data-ttu-id="da668-207">为了说明这一点，假设我们在从数据库中加载大量的文章，以及每个帖子引用的博客。</span><span class="sxs-lookup"><span data-stu-id="da668-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="da668-208">如果发生了100发布以引用同一博客，则跟踪查询将通过标识解析来检测这种情况，并且所有 Post 实例都将引用相同的重复数据的博客实例。</span><span class="sxs-lookup"><span data-stu-id="da668-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="da668-209">相反，无跟踪查询与相同的博客100次重复，并且必须相应地编写应用程序代码。</span><span class="sxs-lookup"><span data-stu-id="da668-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="da668-210">下面是比较跟踪与不跟踪行为的基准比较的结果：加载10个博客，其中每个日志都包含20个帖子。</span><span class="sxs-lookup"><span data-stu-id="da668-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="da668-211">[源代码在此处提供](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs)，可将其用作自己度量的基础。</span><span class="sxs-lookup"><span data-stu-id="da668-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="da668-212">方法</span><span class="sxs-lookup"><span data-stu-id="da668-212">Method</span></span> | <span data-ttu-id="da668-213">NumBlogs</span><span class="sxs-lookup"><span data-stu-id="da668-213">NumBlogs</span></span> | <span data-ttu-id="da668-214">NumPostsPerBlog</span><span class="sxs-lookup"><span data-stu-id="da668-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="da668-215">平均值</span><span class="sxs-lookup"><span data-stu-id="da668-215">Mean</span></span> |    <span data-ttu-id="da668-216">错误</span><span class="sxs-lookup"><span data-stu-id="da668-216">Error</span></span> |   <span data-ttu-id="da668-217">标准偏差</span><span class="sxs-lookup"><span data-stu-id="da668-217">StdDev</span></span> |     <span data-ttu-id="da668-218">中值</span><span class="sxs-lookup"><span data-stu-id="da668-218">Median</span></span> | <span data-ttu-id="da668-219">比率</span><span class="sxs-lookup"><span data-stu-id="da668-219">Ratio</span></span> | <span data-ttu-id="da668-220">RatioSD</span><span class="sxs-lookup"><span data-stu-id="da668-220">RatioSD</span></span> |   <span data-ttu-id="da668-221">第0代</span><span class="sxs-lookup"><span data-stu-id="da668-221">Gen 0</span></span> |   <span data-ttu-id="da668-222">第1代</span><span class="sxs-lookup"><span data-stu-id="da668-222">Gen 1</span></span> | <span data-ttu-id="da668-223">第2代</span><span class="sxs-lookup"><span data-stu-id="da668-223">Gen 2</span></span> | <span data-ttu-id="da668-224">已分配</span><span class="sxs-lookup"><span data-stu-id="da668-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="da668-225">AsTracking</span><span class="sxs-lookup"><span data-stu-id="da668-225">AsTracking</span></span> |       <span data-ttu-id="da668-226">10</span><span class="sxs-lookup"><span data-stu-id="da668-226">10</span></span> |              <span data-ttu-id="da668-227">20</span><span class="sxs-lookup"><span data-stu-id="da668-227">20</span></span> | <span data-ttu-id="da668-228">1414.7 美国</span><span class="sxs-lookup"><span data-stu-id="da668-228">1,414.7 us</span></span> | <span data-ttu-id="da668-229">27.20 美国</span><span class="sxs-lookup"><span data-stu-id="da668-229">27.20 us</span></span> | <span data-ttu-id="da668-230">45.44 美国</span><span class="sxs-lookup"><span data-stu-id="da668-230">45.44 us</span></span> | <span data-ttu-id="da668-231">1405.5 美国</span><span class="sxs-lookup"><span data-stu-id="da668-231">1,405.5 us</span></span> |  <span data-ttu-id="da668-232">1.00</span><span class="sxs-lookup"><span data-stu-id="da668-232">1.00</span></span> |    <span data-ttu-id="da668-233">0.00</span><span class="sxs-lookup"><span data-stu-id="da668-233">0.00</span></span> | <span data-ttu-id="da668-234">60.5469</span><span class="sxs-lookup"><span data-stu-id="da668-234">60.5469</span></span> | <span data-ttu-id="da668-235">13.6719</span><span class="sxs-lookup"><span data-stu-id="da668-235">13.6719</span></span> |     - | <span data-ttu-id="da668-236">380.11 KB</span><span class="sxs-lookup"><span data-stu-id="da668-236">380.11 KB</span></span> |
| <span data-ttu-id="da668-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="da668-237">AsNoTracking</span></span> |       <span data-ttu-id="da668-238">10</span><span class="sxs-lookup"><span data-stu-id="da668-238">10</span></span> |              <span data-ttu-id="da668-239">20</span><span class="sxs-lookup"><span data-stu-id="da668-239">20</span></span> |   <span data-ttu-id="da668-240">993.3 美国</span><span class="sxs-lookup"><span data-stu-id="da668-240">993.3 us</span></span> | <span data-ttu-id="da668-241">24.04 美国</span><span class="sxs-lookup"><span data-stu-id="da668-241">24.04 us</span></span> | <span data-ttu-id="da668-242">65.40 美国</span><span class="sxs-lookup"><span data-stu-id="da668-242">65.40 us</span></span> |   <span data-ttu-id="da668-243">966.2 美国</span><span class="sxs-lookup"><span data-stu-id="da668-243">966.2 us</span></span> |  <span data-ttu-id="da668-244">0.71</span><span class="sxs-lookup"><span data-stu-id="da668-244">0.71</span></span> |    <span data-ttu-id="da668-245">0.05</span><span class="sxs-lookup"><span data-stu-id="da668-245">0.05</span></span> | <span data-ttu-id="da668-246">37.1094</span><span class="sxs-lookup"><span data-stu-id="da668-246">37.1094</span></span> |  <span data-ttu-id="da668-247">6.8359</span><span class="sxs-lookup"><span data-stu-id="da668-247">6.8359</span></span> |     - | <span data-ttu-id="da668-248">232.89 KB</span><span class="sxs-lookup"><span data-stu-id="da668-248">232.89 KB</span></span> |

<span data-ttu-id="da668-249">最后，通过利用无跟踪查询然后将返回的实例附加到上下文中，可以在不影响更改跟踪的开销的情况下执行更新，同时指定要进行的更改。</span><span class="sxs-lookup"><span data-stu-id="da668-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="da668-250">这会将更改跟踪的负担从 EF 传输到用户，并且仅当更改跟踪开销已通过分析或基准证明显示为不可接受时才应尝试。</span><span class="sxs-lookup"><span data-stu-id="da668-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="da668-251">使用原始 SQL</span><span class="sxs-lookup"><span data-stu-id="da668-251">Using raw SQL</span></span>

<span data-ttu-id="da668-252">在某些情况下，你的查询存在更多优化的 SQL，而 EF 不会生成。</span><span class="sxs-lookup"><span data-stu-id="da668-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="da668-253">如果 SQL 构造是特定于您的数据库的扩展，或者是不受支持的，则可能会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="da668-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="da668-254">在这些情况下，手动编写 SQL 可以显著提高性能，而 EF 支持多种方法来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="da668-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="da668-255">[直接在查询中](xref:core/querying/raw-sql)使用原始 SQL，例如通过 <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> 。</span><span class="sxs-lookup"><span data-stu-id="da668-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="da668-256">EF 甚至使你可以使用常规 LINQ 查询来编写原始 SQL，使你能够仅在原始 SQL 中表达部分查询。</span><span class="sxs-lookup"><span data-stu-id="da668-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="da668-257">当只需在代码库中的单个查询中使用原始 SQL 时，这是一种很好的方法。</span><span class="sxs-lookup"><span data-stu-id="da668-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="da668-258">定义 (UDF) 的 [用户定义函数](xref:core/querying/database-functions) ，然后从查询中调用该函数。</span><span class="sxs-lookup"><span data-stu-id="da668-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="da668-259">请注意，从5.0 开始，Udf 允许 Udf 返回完整结果集-这些函数称为表值函数 (Tvf) -并且还允许将映射 `DbSet` 到函数，使其看起来就像是另一个表。</span><span class="sxs-lookup"><span data-stu-id="da668-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="da668-260">定义数据库视图，并在查询中对其进行查询。</span><span class="sxs-lookup"><span data-stu-id="da668-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="da668-261">请注意，与函数不同，视图不能接受参数。</span><span class="sxs-lookup"><span data-stu-id="da668-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="da668-262">通常，在确保 EF 无法生成所需的 SQL 时，以及当性能非常重要，足以使给定的查询进行调整时，通常应将原始 SQL 用作最后的手段。</span><span class="sxs-lookup"><span data-stu-id="da668-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="da668-263">使用原始 SQL 会带来相当大的维护缺点。</span><span class="sxs-lookup"><span data-stu-id="da668-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="da668-264">异步编程</span><span class="sxs-lookup"><span data-stu-id="da668-264">Asynchronous programming</span></span>

<span data-ttu-id="da668-265">作为一般规则，若要使应用程序具有可伸缩性，必须始终使用异步 Api，而不是同步 (例如， <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> 而不是 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="da668-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="da668-266">同步 Api 在数据库 i/o 期间阻止线程，从而增加了对线程的需要和必须发生的线程上下文切换次数。</span><span class="sxs-lookup"><span data-stu-id="da668-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="da668-267">有关详细信息，请参阅 [异步编程](xref:core/miscellaneous/async)中的页面。</span><span class="sxs-lookup"><span data-stu-id="da668-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="da668-268">避免在同一应用程序中混合同步和异步代码，这很容易意外触发微妙的线程池不足问题。</span><span class="sxs-lookup"><span data-stu-id="da668-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="da668-269">其他资源</span><span class="sxs-lookup"><span data-stu-id="da668-269">Additional resources</span></span>

<span data-ttu-id="da668-270">请参阅 null 比较文档页的 " [性能" 部分](xref:core/querying/null-comparisons#writing-performant-queries) ，了解比较可为 null 值时的一些最佳实践。</span><span class="sxs-lookup"><span data-stu-id="da668-270">See the [performance section](xref:core/querying/null-comparisons#writing-performant-queries) of the null comparison documentation page for some best practices when comparing nullable values.</span></span>
