---
title: 客户端与服务器评估 - EF Core
description: 使用 Entity Framework Core 进行客户端和服务器查询评估
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/client-eval
ms.openlocfilehash: a1ddfb625be36cb05f01da08eb3be29512c54ab5
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2020
ms.locfileid: "94430139"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="4c335-103">客户端与服务器评估</span><span class="sxs-lookup"><span data-stu-id="4c335-103">Client vs. Server Evaluation</span></span>

<span data-ttu-id="4c335-104">作为一般规则，Entity Framework Core 会尝试尽可能全面地评估服务器上的查询。</span><span class="sxs-lookup"><span data-stu-id="4c335-104">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="4c335-105">EF Core 将查询的一部分转换为可在客户端评估的参数。</span><span class="sxs-lookup"><span data-stu-id="4c335-105">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="4c335-106">系统将查询的其余部分（及生成的参数）提供给数据库提供程序，以确定要在服务器上评估的等效数据库查询。</span><span class="sxs-lookup"><span data-stu-id="4c335-106">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="4c335-107">EF Core 支持在顶级投影中进行部分客户端评估（基本上为最后一次调用 `Select()`）。</span><span class="sxs-lookup"><span data-stu-id="4c335-107">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="4c335-108">如果查询中的顶级投影无法转换为服务器，EF Core 将从服务器中提取任何所需的数据，并在客户端上评估查询的其余部分。</span><span class="sxs-lookup"><span data-stu-id="4c335-108">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="4c335-109">如果 EF Core 在顶级投影之外的任何位置检测到不能转换为服务器的表达式，则会引发运行时异常。</span><span class="sxs-lookup"><span data-stu-id="4c335-109">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="4c335-110">请参阅[查询工作原理](xref:core/querying/how-query-works)，了解 EF Core 如何确定哪些表达式无法转换为服务器。</span><span class="sxs-lookup"><span data-stu-id="4c335-110">See [How queries work](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="4c335-111">在 3.0 版之前，Entity Framework Core 支持在查询中的任何位置进行客户端评估。</span><span class="sxs-lookup"><span data-stu-id="4c335-111">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="4c335-112">有关详细信息，请参阅[历史版本部分](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="4c335-112">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="4c335-113">可在 GitHub 上查看此文章的[示例](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/ClientEvaluation)。</span><span class="sxs-lookup"><span data-stu-id="4c335-113">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/ClientEvaluation) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="4c335-114">顶级投影中的客户端评估</span><span class="sxs-lookup"><span data-stu-id="4c335-114">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="4c335-115">在下面的示例中，一个辅助方法用于标准化从 SQL Server 数据库中返回的博客的 URL。</span><span class="sxs-lookup"><span data-stu-id="4c335-115">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="4c335-116">由于 SQL Server 提供程序不了解此方法的实现方式，因此无法将其转换为 SQL。</span><span class="sxs-lookup"><span data-stu-id="4c335-116">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="4c335-117">查询的所有其余部分是在数据库中评估的，但通过此方法传递返回的 `URL` 却是在客户端上完成。</span><span class="sxs-lookup"><span data-stu-id="4c335-117">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="4c335-118">不支持的客户端评估</span><span class="sxs-lookup"><span data-stu-id="4c335-118">Unsupported client evaluation</span></span>

<span data-ttu-id="4c335-119">尽管客户端评估非常有用，但有时会减弱性能。</span><span class="sxs-lookup"><span data-stu-id="4c335-119">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="4c335-120">请看以下查询，其中的 where 筛选器现已使用辅助方法。</span><span class="sxs-lookup"><span data-stu-id="4c335-120">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="4c335-121">由于数据库中不能应用筛选器，因此需要将所有数据提取到内存中，以便在客户端上应用筛选器。</span><span class="sxs-lookup"><span data-stu-id="4c335-121">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="4c335-122">根据服务器上的筛选器和数据量，客户端评估可能会减弱性能。</span><span class="sxs-lookup"><span data-stu-id="4c335-122">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="4c335-123">因此 Entity Framework Core 会阻止此类客户端评估，并引发运行时异常。</span><span class="sxs-lookup"><span data-stu-id="4c335-123">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="4c335-124">显式客户端评估</span><span class="sxs-lookup"><span data-stu-id="4c335-124">Explicit client evaluation</span></span>

<span data-ttu-id="4c335-125">在某些情况下，可能需要以显式方式强制进行客户端评估，如下所示</span><span class="sxs-lookup"><span data-stu-id="4c335-125">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="4c335-126">由于数据量小，因此在进行客户端评估时才不会大幅减弱性能。</span><span class="sxs-lookup"><span data-stu-id="4c335-126">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="4c335-127">所用的 LINQ 运算符不会进行任何服务器端转换。</span><span class="sxs-lookup"><span data-stu-id="4c335-127">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="4c335-128">在这种情况下，通过调用 `AsEnumerable` 或 `ToList` 等方法（若为异步，则调用 `AsAsyncEnumerable` 或 `ToListAsync`），以显式方式选择进行客户端评估。</span><span class="sxs-lookup"><span data-stu-id="4c335-128">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="4c335-129">使用 `AsEnumerable` 将对结果进行流式传输，但使用 `ToList` 将通过创建列表来进行缓冲，因此也会占用额外的内存。</span><span class="sxs-lookup"><span data-stu-id="4c335-129">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="4c335-130">但如果枚举多次，则将结果存储到列表中可以带来更大的帮助，因为只有一个对数据库的查询。</span><span class="sxs-lookup"><span data-stu-id="4c335-130">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="4c335-131">根据具体的使用情况，你应该评估哪种方法更适合。</span><span class="sxs-lookup"><span data-stu-id="4c335-131">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ExplicitClientEvaluation)]

> [!TIP]
> <span data-ttu-id="4c335-132">如果你正在使用 `AsAsyncEnumerable` 并希望在客户端进一步编写查询，可以使用用于定义异步枚举运算符的 [System.Interactive.Async](https://www.nuget.org/packages/System.Interactive.Async/) 库。</span><span class="sxs-lookup"><span data-stu-id="4c335-132">If you are using `AsAsyncEnumerable` and want to compose the query further on client side then you can use [System.Interactive.Async](https://www.nuget.org/packages/System.Interactive.Async/) library which defines operators for async enumerables.</span></span> <span data-ttu-id="4c335-133">有关详细信息，请参阅[客户端 linq 运算符](xref:core/miscellaneous/async#client-side-async-linq-operators)。</span><span class="sxs-lookup"><span data-stu-id="4c335-133">For more information, see [client side linq operators](xref:core/miscellaneous/async#client-side-async-linq-operators).</span></span>

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="4c335-134">客户端评估中潜在的内存泄漏</span><span class="sxs-lookup"><span data-stu-id="4c335-134">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="4c335-135">由于查询转换和编译的开销高昂，因此 EF Core 会缓存已编译的查询计划。</span><span class="sxs-lookup"><span data-stu-id="4c335-135">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="4c335-136">缓存的委托在对顶级投影进行客户端评估时可能会使用客户端代码。</span><span class="sxs-lookup"><span data-stu-id="4c335-136">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="4c335-137">EF Core 为树型结构中客户端评估的部分生成参数，并通过替换参数值重用查询计划。</span><span class="sxs-lookup"><span data-stu-id="4c335-137">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="4c335-138">但表达式树中的某些常数无法转换为参数。</span><span class="sxs-lookup"><span data-stu-id="4c335-138">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="4c335-139">如果缓存的委托包含此类常数，则无法将这些对象垃圾回收，因为它们仍被引用。</span><span class="sxs-lookup"><span data-stu-id="4c335-139">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="4c335-140">如果此类对象包含 DbContext 或其中的其他服务，则会导致应用的内存使用量逐渐增多。</span><span class="sxs-lookup"><span data-stu-id="4c335-140">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="4c335-141">此行为通常是内存泄漏的标志。</span><span class="sxs-lookup"><span data-stu-id="4c335-141">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="4c335-142">只要遇到的常数为不能使用当前数据库提供程序映射的类型，EF Core 就会引发异常。</span><span class="sxs-lookup"><span data-stu-id="4c335-142">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="4c335-143">常见原因及其解决方案如下所示：</span><span class="sxs-lookup"><span data-stu-id="4c335-143">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="4c335-144">**使用实例方法**：在客户端投影中使用实例方法时，表达式树包含实例的常数。</span><span class="sxs-lookup"><span data-stu-id="4c335-144">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="4c335-145">如果你的方法不使用该实例中的任何数据，请考虑将该方法设为静态方法。</span><span class="sxs-lookup"><span data-stu-id="4c335-145">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="4c335-146">如果需要方法主体中的实例数据，则将特定数据作为实参传递给方法。</span><span class="sxs-lookup"><span data-stu-id="4c335-146">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="4c335-147">**将常数实参传递给方法**：这种情况通常是由于在客户端方法的实参中使用 `this` 引起的。</span><span class="sxs-lookup"><span data-stu-id="4c335-147">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="4c335-148">请考虑将实参拆分为多个标量实参，可由数据库提供程序进行映射。</span><span class="sxs-lookup"><span data-stu-id="4c335-148">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="4c335-149">**其他常数**：如果在任何其他情况下都出现常数，则可以评估在处理过程中是否需要该常数。</span><span class="sxs-lookup"><span data-stu-id="4c335-149">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="4c335-150">如果必须具有常数，或者如果无法使用上述情况中的解决方案，则创建本地变量来存储值，并在查询中使用局部变量。</span><span class="sxs-lookup"><span data-stu-id="4c335-150">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="4c335-151">EF Core 会将局部变量转换为形参。</span><span class="sxs-lookup"><span data-stu-id="4c335-151">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="4c335-152">早期版本</span><span class="sxs-lookup"><span data-stu-id="4c335-152">Previous versions</span></span>

<span data-ttu-id="4c335-153">以下部分适用于 3.0 以前的 EF Core 版本。</span><span class="sxs-lookup"><span data-stu-id="4c335-153">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="4c335-154">旧的 EF Core 版本支持在查询的任何部分中进行客户端评估，而不仅仅是顶级投影。</span><span class="sxs-lookup"><span data-stu-id="4c335-154">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="4c335-155">因此，与[不支持的客户评估](#unsupported-client-evaluation)部分下发布的查询类似的查询可以正常工作。</span><span class="sxs-lookup"><span data-stu-id="4c335-155">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="4c335-156">由于此行为可能引起不易觉察的性能问题，EF Core 记录了客户端评估警告。</span><span class="sxs-lookup"><span data-stu-id="4c335-156">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="4c335-157">有关如何查看日志记录输出的详细信息，请参阅[日志记录](xref:core/logging-events-diagnostics/index)。</span><span class="sxs-lookup"><span data-stu-id="4c335-157">For more information on viewing logging output, see [Logging](xref:core/logging-events-diagnostics/index).</span></span>

<span data-ttu-id="4c335-158">（可选）借助 EF Core，你可以将默认行为更改为在执行客户端评估时引发异常或不执行任何操作（在投影中除外）。</span><span class="sxs-lookup"><span data-stu-id="4c335-158">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="4c335-159">引发异常的行为会使其类似于 3.0 中的行为。</span><span class="sxs-lookup"><span data-stu-id="4c335-159">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="4c335-160">若要更改该行为，你需要在设置上下文选项时配置警告。上下文选项一般在 `DbContext.OnConfiguring` 中设置，如果使用 ASP.NET Core，则在 `Startup.cs` 中设置。</span><span class="sxs-lookup"><span data-stu-id="4c335-160">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
