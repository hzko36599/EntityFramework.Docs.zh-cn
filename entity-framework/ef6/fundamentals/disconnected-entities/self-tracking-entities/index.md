---
title: 自跟踪实体 - EF6
description: Entity Framework 6 中的自跟踪实体
author: ajcvickers
ms.date: 10/23/2016
uid: ef6/fundamentals/disconnected-entities/self-tracking-entities/index
ms.openlocfilehash: 56bcd79d0c9949b9ccc06efe4dbc5a36bb88b158
ms.sourcegitcommit: 0a25c03fa65ae6e0e0e3f66bac48d59eceb96a5a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/14/2020
ms.locfileid: "92065545"
---
# <a name="self-tracking-entities"></a><span data-ttu-id="b4b0b-103">自跟踪实体</span><span class="sxs-lookup"><span data-stu-id="b4b0b-103">Self-tracking entities</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b4b0b-104">我们不再建议使用自跟踪实体模板。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-104">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="b4b0b-105">它将仅继续用于支持现有应用程序。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-105">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="b4b0b-106">如果应用程序需要使用断开连接的实体图，请考虑其他替代方案，例如[可跟踪实体](https://trackableentities.github.io/)，它与自跟踪实体类似，社区在更积极地开发这种技术，或使用低级别更改跟踪 API 编写自定义代码。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-106">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="b4b0b-107">在基于实体框架的应用程序中，上下文负责跟踪对象中的更改。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-107">In an Entity Framework-based application, a context is responsible for tracking changes in your objects.</span></span> <span data-ttu-id="b4b0b-108">然后，使用 SaveChanges 方法将更改保存到数据库。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-108">You then use the SaveChanges method to persist the changes to the database.</span></span> <span data-ttu-id="b4b0b-109">使用 N 层应用程序时，实体对象通常会从上下文断开连接，用户必须决定如何跟踪更改并向上下文报告这些更改。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-109">When working with N-Tier applications, the entity objects are usually disconnected from the context and you must decide how to track changes and report those changes back to the context.</span></span> <span data-ttu-id="b4b0b-110">自跟踪实体 (STE) 有助于跟踪任意层中的更改，之后可将这些更改重放入上下文中进行保存。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-110">Self-Tracking Entities (STEs) can help you track changes in any tier and then replay these changes into a context to be saved.</span></span>  

<span data-ttu-id="b4b0b-111">仅当上下文在更改对象图所在的层上不可用时才使用 STE。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-111">Use STEs only if the context is not available on a tier where the changes to the object graph are made.</span></span> <span data-ttu-id="b4b0b-112">如果上下文可用，则无需使用 STE，因为上下文将负责跟踪更改。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-112">If the context is available, there is no need to use STEs because the context will take care of tracking changes.</span></span>  

<span data-ttu-id="b4b0b-113">此模板项会生成两个 .tt（文本模板）文件：</span><span class="sxs-lookup"><span data-stu-id="b4b0b-113">This template item generates two .tt (text template) files:</span></span>  

- <span data-ttu-id="b4b0b-114">\<model name\>.tt 文件可生成实体类型、包含自跟踪实体使用的更改跟踪逻辑的 Helper 类以及允许设置自跟踪实体的状态的扩展方法。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-114">The **\<model name\>.tt** file generates the entity types and a helper class that contains the change-tracking logic that is used by self-tracking entities and the extension methods that allow setting state on self-tracking entities.</span></span>  
- <span data-ttu-id="b4b0b-115">\<model name\>.Context.tt 文件生成派生的上下文和扩展类，该类包含 ObjectContext 和 ObjectSet 类的 ApplyChanges 方法。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-115">The **\<model name\>.Context.tt** file generates a derived context and an extension class that contains **ApplyChanges** methods for the **ObjectContext** and **ObjectSet** classes.</span></span> <span data-ttu-id="b4b0b-116">这些方法检查自跟踪实体图中包含的更改跟踪信息，以推断在数据库中保存这些更改所必须执行的一组操作。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-116">These methods examine the change-tracking information that is contained in the graph of self-tracking entities to infer the set of operations that must be performed to save the changes in the database.</span></span>  

## <a name="get-started"></a><span data-ttu-id="b4b0b-117">入门</span><span class="sxs-lookup"><span data-stu-id="b4b0b-117">Get Started</span></span>  

<span data-ttu-id="b4b0b-118">若要开始操作，请访问[自跟踪实体演练](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough)页。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-118">To get started, visit the [Self-Tracking Entities Walkthrough](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough) page.</span></span>  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a><span data-ttu-id="b4b0b-119">使用自跟踪实体时的功能性注意事项</span><span class="sxs-lookup"><span data-stu-id="b4b0b-119">Functional Considerations When Working with Self-Tracking Entities</span></span>  
> [!IMPORTANT]
> <span data-ttu-id="b4b0b-120">我们不再建议使用自跟踪实体模板。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-120">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="b4b0b-121">它将仅继续用于支持现有应用程序。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-121">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="b4b0b-122">如果应用程序需要使用断开连接的实体图，请考虑其他替代方案，例如[可跟踪实体](https://trackableentities.github.io/)，它与自跟踪实体类似，社区在更积极地开发这种技术，或使用低级别更改跟踪 API 编写自定义代码。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-122">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="b4b0b-123">使用自跟踪实体时应考虑以下事项：</span><span class="sxs-lookup"><span data-stu-id="b4b0b-123">Consider the following when working with self-tracking entities:</span></span>  

- <span data-ttu-id="b4b0b-124">确保您的客户端项目具有对包含实体类型的程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-124">Make sure that your client project has a reference to the assembly containing the entity types.</span></span> <span data-ttu-id="b4b0b-125">如果您只将服务引用添加到客户端项目，则客户端项目将使用 WCF 代理类型，而不是实际的自跟踪实体类型。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-125">If you add only the service reference to the client project, the client project will use the WCF proxy types and not the actual self-tracking entity types.</span></span> <span data-ttu-id="b4b0b-126">这意味着您将不能获得管理客户端上实体跟踪的自动通知功能。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-126">This means that you will not get the automated notification features that manage the tracking of the entities on the client.</span></span> <span data-ttu-id="b4b0b-127">如果您不希望包含实体类型，则必须手动设置客户端的更改跟踪信息以便将更改发送回服务。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-127">If you intentionally do not want to include the entity types, you will have to manually set change-tracking information on the client for the changes to be sent back to the service.</span></span>  
- <span data-ttu-id="b4b0b-128">对服务操作的调用应是无状态的，并且创建一个新的对象上下文实例。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-128">Calls to the service operation should be stateless and create a new instance of object context.</span></span> <span data-ttu-id="b4b0b-129">同样建议在 using 块中创建对象上下文\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-129">We also recommend that you create object context in a **using** block.</span></span>  
- <span data-ttu-id="b4b0b-130">如果在将客户端上已修改的图发送到服务后想要在客户端上继续使用同一张图，则必须手动循环访问该图，并对每个对象调用 AcceptChanges 方法以重置更改跟踪器\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-130">When you send the graph that was modified on the client to the service and then intend to continue working with the same graph on the client, you have to manually iterate through the graph and call the **AcceptChanges** method on each object to reset the change tracker.</span></span>  

    > <span data-ttu-id="b4b0b-131">如果图中的对象包含具有数据库生成的值（例如，标识值或并发值）的属性，则在调用 SaveChanges 方法后，实体框架将把这些属性的值替换为数据库生成的值\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-131">If objects in your graph contain properties with database-generated values (for example, identity or concurrency values), Entity Framework will replace values of these properties with the database-generated values after the **SaveChanges** method is called.</span></span> <span data-ttu-id="b4b0b-132">可实现服务操作以返回保存的对象或生成的属性值列表，从而将对象发送回客户端。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-132">You can implement your service operation to return saved objects or a list of generated property values for the objects back to the client.</span></span> <span data-ttu-id="b4b0b-133">然后，客户端需要将对象实例或对象属性值替换为从服务操作返回的对象或属性值。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-133">The client would then need to replace the object instances or object property values with the objects or property values returned from the service operation.</span></span>  
- <span data-ttu-id="b4b0b-134">合并多个服务请求的关系图可能会在生成的关系图中引入具有重复键值的对象。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-134">Merging graphs from multiple service requests may introduce objects with duplicate key values in the resulting graph.</span></span> <span data-ttu-id="b4b0b-135">调用 ApplyChanges 方法时，实体框架不会删除具有重复键的对象，但会引发异常\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-135">Entity Framework does not remove the objects with duplicate keys when you call the **ApplyChanges** method but instead throws an exception.</span></span> <span data-ttu-id="b4b0b-136">为了避免生成具有重复键值的图，请遵循以下博客中所述的模式之一：[自跟踪实体：ApplyChanges 和重复实体](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409)。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-136">To avoid having graphs with duplicate key values follow one of the patterns described in the following blog: [Self-Tracking Entities: ApplyChanges and duplicate entities](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span></span>  
- <span data-ttu-id="b4b0b-137">当您通过设置外键属性更改对象之间的关系时，引用导航属性设置为 Null，并且不同步到客户端上的相应主体实体。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-137">When you change the relationship between objects by setting the foreign key property, the reference navigation property is set to null and not synchronized to the appropriate principal entity on the client.</span></span> <span data-ttu-id="b4b0b-138">将图附加到对象上下文之后（例如，调用 ApplyChanges 方法之后），会同步外键属性和导航属性\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-138">After the graph is attached to the object context (for example, after you call the **ApplyChanges** method), the foreign key properties and navigation properties are synchronized.</span></span>  

    > <span data-ttu-id="b4b0b-139">如果您已对外键关系指定级联删除，则引用导航属性与相应主体对象不同步会是个问题。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-139">Not having a reference navigation property synchronized with the appropriate principal object could be an issue if you have specified cascade delete on the foreign key relationship.</span></span> <span data-ttu-id="b4b0b-140">如果您删除了主体，则这种删除将不会传播到依赖对象。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-140">If you delete the principal, the delete will not be propagated to the dependent objects.</span></span> <span data-ttu-id="b4b0b-141">如果您已指定级联删除，则使用导航属性更改关系，而不是设置外键属性。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-141">If you have cascade deletes specified, use navigation properties to change relationships instead of setting the foreign key property.</span></span>  
- <span data-ttu-id="b4b0b-142">执行延迟加载时不启用自跟踪实体。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-142">Self-tracking entities are not enabled to perform lazy loading.</span></span>  
- <span data-ttu-id="b4b0b-143">自跟踪实体不支持二进制序列化和针对 ASP.NET 状态管理对象的序列化。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-143">Binary serialization and serialization to ASP.NET state management objects is not supported by self-tracking entities.</span></span> <span data-ttu-id="b4b0b-144">但是，您可以自定义此模板来添加二进制序列化支持。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-144">However, you can customize the template to add the binary serialization support.</span></span> <span data-ttu-id="b4b0b-145">有关详细信息，请参阅[将二进制序列化和 ViewState 用于自跟踪实体](https://go.microsoft.com/fwlink/?LinkId=199208)。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-145">For more information, see [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208).</span></span>  

## <a name="security-considerations"></a><span data-ttu-id="b4b0b-146">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="b4b0b-146">Security Considerations</span></span>  

<span data-ttu-id="b4b0b-147">使用自跟踪实体时，应考虑以下安全注意事项：</span><span class="sxs-lookup"><span data-stu-id="b4b0b-147">The following security considerations should be taken into account when working with self-tracking entities:</span></span>  

- <span data-ttu-id="b4b0b-148">服务不应信任从不受信任的客户端或通过不受信任的通道检索或更新数据的请求。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-148">A service should not trust requests to retrieve or update data from a non-trusted client or through a non-trusted channel.</span></span> <span data-ttu-id="b4b0b-149">客户端必须经身份验证：应使用安全通道或消息信封。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-149">A client must be authenticated: a secure channel or message envelope should be used.</span></span> <span data-ttu-id="b4b0b-150">必须验证客户端更新或检索数据的请求，从而确保这些请求符合对于给定方案合法的预期更改。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-150">Clients' requests to update or retrieve data must be validated to ensure they conform to expected and legitimate changes for the given scenario.</span></span>  
- <span data-ttu-id="b4b0b-151">避免将敏感信息用作实体键（例如身份证号码）。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-151">Avoid using sensitive information as entity keys (for example, social security numbers).</span></span> <span data-ttu-id="b4b0b-152">这样可降低意外地将自跟踪实体图中的敏感信息序列化到不完全可信的客户端的可能性。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-152">This mitigates the possibility of inadvertently serializing sensitive information in the self-tracking entity graphs to a client that is not fully trusted.</span></span> <span data-ttu-id="b4b0b-153">通过使用独立关联，实体中与正在序列化的键相关的原始键也可能会发送到客户端。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-153">With independent associations, the original key of an entity that is related to the one that is being serialized might be sent to the client as well.</span></span>  
- <span data-ttu-id="b4b0b-154">为了避免向客户端层传播包含敏感数据的异常消息，应将服务器层上对 ApplyChanges 和 SaveChanges 的调用包装到异常处理代码中\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="b4b0b-154">To avoid propagating exception messages that contain sensitive data to the client tier, calls to **ApplyChanges** and **SaveChanges** on the server tier should be wrapped in exception-handling code.</span></span>  
